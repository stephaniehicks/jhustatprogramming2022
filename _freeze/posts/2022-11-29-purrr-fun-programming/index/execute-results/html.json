{
  "hash": "f68b480b08add3411b524025f5ef243b",
  "result": {
    "markdown": "---\ntitle: \"Functional Programming with `purrr`\"\nauthor: \n  - name: Boyi Guo\n    url: https://boyiguo1.github.io\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to tools to work with functions and vectors in R\"\ndate: 2022-11-29\ncategories: [module 3, week 6, functions, functional, programming, purrr]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://adv-r.hadley.nz/functionals.html>\n2.  <https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf>\n:::\n\n\n### Prerequisites\nBefore starting you must install the additional package:\n\n* `purrr` - this provides a consistent functional programming interface to work with functions and vectors\n\nYou can do this by calling\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"purrr\")\n```\n:::\n\n\nor use the “Install Packages…” option from the “Tools” menu in RStudio.\n\n\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://adv-r.hadley.nz/fp.html>\n-   <https://adv-r.hadley.nz/functionals.html>\n-   <https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be familiar with the concept of _functional programming_\n-   Get comfortable with the major functions in  `purrr`, e.g. the `map` family, `reduce`\n-   Write your loops with `map` functions instead of the `for` loop\n:::\n\n# Functional Programming\n## The characteristics\nAt it is core, functional programming treats functions equally as other data structures, namely **first class functions**. \n\n> In R, this means that you can do many of the things with a function that you can do with a vector: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.\n\n## What do you mean?\n\n* Assign a function to a variable\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- function(){\n  return(\"This is foo.\")\n}\nclass(foo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n:::\n\n\n* Store functions in a list\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo_list <- list( \n  fun_1 = function() return(\"foo_1\"),\n  fun_2 = function() return(\"foo_2\")\n)\n\nstr(foo_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ fun_1:function ()  \n  ..- attr(*, \"srcref\")= 'srcref' int [1:8] 2 11 2 36 11 36 2 2\n  .. ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7f925303de48> \n $ fun_2:function ()  \n  ..- attr(*, \"srcref\")= 'srcref' int [1:8] 3 11 3 36 11 36 3 3\n  .. ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7f925303de48> \n```\n:::\n:::\n\n\n* Pass functions as arguments to other functions\n\n::: {.cell}\n\n```{.r .cell-code}\nshell <- function(f) f()\nshell(foo_list$fun_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"foo_1\"\n```\n:::\n\n```{.r .cell-code}\nshell(foo_list$fun_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"foo_2\"\n```\n:::\n:::\n\n\n* Create functions inside of functions & return them as the result of a function\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo_wrap <- function(){\n  foo_2 <- function(){\n    return(\"This is foo_2.\")\n  }\n  return(foo_2)\n}\n\nfoo_wrap()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction(){\n    return(\"This is foo_2.\")\n  }\n<environment: 0x7f92410bf898>\n```\n:::\n\n```{.r .cell-code}\n(foo_wrap())()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This is foo_2.\"\n```\n:::\n:::\n\n\nThe bottom line, you can manipulate functions as the same way as you can to a vector or a matrix. \n\n## Why is functional programming important?\nFunctional programming introduces a new style of programming, namely **functional style**. Broadly speaking, this programming style encourages programmers to write a big function as many smaller isolated functions, where each function addresses one specific task.\n\n<iframe src='https://gfycat.com/ifr/NeedyRipeKingbird' frameborder='0' scrolling='no' allowfullscreen width='640' height='404'></iframe>\n\nAs a by-product, **funcitonal style** motivates more humanly readable code, and recyclable code.\n\n::: {.cell}\n\n```{.r .cell-code}\n\"data_set.csv\" |> \n  import_data_from_file() |> \n  data_cleaning() |> \n  run_regression() |>\n  model_diagnostics() |>\n  model_visualization()\n\n\"data_set2.csv\" |> \n  import_data_from_file() |> \n  data_cleaning() |> \n  run_different_regression() |>\n  model_diagnostics() |>\n  model_visualization()\n```\n:::\n\n\n::: callout-tip\n### Pipe operators\nR provides some pipe operators to make code readable, e.g. `|>` from the base R, `%>%` from the package `magrittr`. These pipe operators operate like a pipe, piping the output from the previous function (left hand side of the pipe operator)  to the following function (right hand side of the pipe operator). The pipe operator `|>` was introduced in R 4.1.0 and requires no loading of additional packages, unlike `%>%`.\n\nA keyboard shortcut to type a pipe operator in RStudio is `shift+cmd+m` for Mac or `shift+ctrl+m` in Windows.\n:::\n\n# `purrr`: the functional programming toolkit\n\n<iframe src='https://gfycat.com/ifr/SadYoungKawala' frameborder='0' scrolling='no' allowfullscreen width='640' height='415'></iframe>\n\nThe R package `purrr`, as one important component of the [`tidyverse`](https://www.tidyverse.org/), provides a interface to manipulate vectors in the _functional style_.\n\n> `purrr` enhances R’s functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors.\n\n::: callout-tip\n### `purrr` cheatsheet\nIt is very difficulty, if not impossible, to remember all functions that a package offers as well as their use cases. Hence, `purrr` developers offer a nice compact cheatsheet with visualizations at <https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf>. Similar cheatsheets are available for other `tidyverse` packages.\n:::\n\nThe most popular function in `purrr` is `map()` which iterates over the supplied data structure and apply a function during the iterations. Beside the `map` function,`purrr` also offers a series of useful functions to manipulate `list` the data structure.\n\n\n## The `map` family\nThe `map` family of functions provides a convenient way to iterate through vectors or lists and apply functions during this iteration. Depending on the dimension of the input and the format of the output, there are many different variants of the basic `map` function.\n\n::: callout-tip\n### How does `map` relate to functional programming\nBecause their arguments include functions (`.f`) besides data (`.x`), `map` functions are considered as a convinient interface to implement functional programming.\n:::\n\n\n### `map` as a foor loop\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n\ntriple <- function(x) x * 3\n\n# for loop\nloop_ret <- list()\nfor(i in 1:3){\n  loop_ret[i] <- triple(i)\n}\n\n# map implementation\nmap_eg1 <- map(.x = 1:3, .f = triple)\nmap_eg2 <- map(.x = 1:3, .f = ~triple(.x))\nmap_eg3 <- map(.x = 1:3, .f = function(x) triple(x))\n\nidentical(loop_ret,map_eg1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(loop_ret,map_eg2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(loop_ret,map_eg3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### `map` with a data frame\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp_dat <- data.frame(\n  x = 1:5,\n  y = 6:10\n)\n\ntmp_dat |> \n  map(.f = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] 3\n\n$y\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n# Alternatively\n# map(.x = tmp_dat, .f = mean)\n```\n:::\n\n\n::: callout-tip\n### `data.frame` vs `list`\n`data.frame` is a special case of `list`, where each column as one item of the list. Don't confuse with each row as an item.\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(tmp_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(tmp_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n:::\n\n### Extra arguments for functions\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp_dat2 <- as.list(tmp_dat)\ntmp_dat2$y[6] <- NA\nstr(tmp_dat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ x: int [1:5] 1 2 3 4 5\n $ y: int [1:6] 6 7 8 9 10 NA\n```\n:::\n\n```{.r .cell-code}\ntmp_dat2 |> map(.f = mean) # No extra arguments\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] 3\n\n$y\n[1] NA\n```\n:::\n\n```{.r .cell-code}\ntmp_dat2 |> \n  map(.f = mean, na.rm = TRUE) # With extra arguments\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] 3\n\n$y\n[1] 8\n```\n:::\n\n```{.r .cell-code}\ntmp_dat2 |> \n  map(.f = function(x, remove_na) mean(x, na.rm = remove_na),\n      remove_na = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] 3\n\n$y\n[1] 8\n```\n:::\n:::\n\n\n### Stratified analysis with `map`\nWe use the `mtcars` from the package `datasets` to demonstrate\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(datasets)\nstr(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n```\n:::\n\n```{.r .cell-code}\nunique(mtcars$cyl) # different numbers of cylinders\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6 4 8\n```\n:::\n:::\n\n\nWe are interested in the averaged miles per gallon for vehicles with different numbers of cylinders\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a dataset for cylinders level\nstr_dat <- mtcars |> split(mtcars$cyl)\nlength(str_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nstr(str_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ 4:'data.frame':\t11 obs. of  11 variables:\n  ..$ mpg : num [1:11] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26 30.4 ...\n  ..$ cyl : num [1:11] 4 4 4 4 4 4 4 4 4 4 ...\n  ..$ disp: num [1:11] 108 146.7 140.8 78.7 75.7 ...\n  ..$ hp  : num [1:11] 93 62 95 66 52 65 97 66 91 113 ...\n  ..$ drat: num [1:11] 3.85 3.69 3.92 4.08 4.93 4.22 3.7 4.08 4.43 3.77 ...\n  ..$ wt  : num [1:11] 2.32 3.19 3.15 2.2 1.61 ...\n  ..$ qsec: num [1:11] 18.6 20 22.9 19.5 18.5 ...\n  ..$ vs  : num [1:11] 1 1 1 1 1 1 1 1 0 1 ...\n  ..$ am  : num [1:11] 1 0 0 1 1 1 0 1 1 1 ...\n  ..$ gear: num [1:11] 4 4 4 4 4 4 3 4 5 5 ...\n  ..$ carb: num [1:11] 1 2 2 1 2 1 1 1 2 2 ...\n $ 6:'data.frame':\t7 obs. of  11 variables:\n  ..$ mpg : num [1:7] 21 21 21.4 18.1 19.2 17.8 19.7\n  ..$ cyl : num [1:7] 6 6 6 6 6 6 6\n  ..$ disp: num [1:7] 160 160 258 225 168 ...\n  ..$ hp  : num [1:7] 110 110 110 105 123 123 175\n  ..$ drat: num [1:7] 3.9 3.9 3.08 2.76 3.92 3.92 3.62\n  ..$ wt  : num [1:7] 2.62 2.88 3.21 3.46 3.44 ...\n  ..$ qsec: num [1:7] 16.5 17 19.4 20.2 18.3 ...\n  ..$ vs  : num [1:7] 0 0 1 1 1 1 0\n  ..$ am  : num [1:7] 1 1 0 0 0 0 1\n  ..$ gear: num [1:7] 4 4 3 3 4 4 5\n  ..$ carb: num [1:7] 4 4 1 1 4 4 6\n $ 8:'data.frame':\t14 obs. of  11 variables:\n  ..$ mpg : num [1:14] 18.7 14.3 16.4 17.3 15.2 10.4 10.4 14.7 15.5 15.2 ...\n  ..$ cyl : num [1:14] 8 8 8 8 8 8 8 8 8 8 ...\n  ..$ disp: num [1:14] 360 360 276 276 276 ...\n  ..$ hp  : num [1:14] 175 245 180 180 180 205 215 230 150 150 ...\n  ..$ drat: num [1:14] 3.15 3.21 3.07 3.07 3.07 2.93 3 3.23 2.76 3.15 ...\n  ..$ wt  : num [1:14] 3.44 3.57 4.07 3.73 3.78 ...\n  ..$ qsec: num [1:14] 17 15.8 17.4 17.6 18 ...\n  ..$ vs  : num [1:14] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ am  : num [1:14] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ gear: num [1:14] 3 3 3 3 3 3 3 3 3 3 ...\n  ..$ carb: num [1:14] 2 4 3 3 3 4 4 4 2 2 ...\n```\n:::\n\n```{.r .cell-code}\nstr_dat |> \n  map(.f = ~mean(.x$mpg))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`4`\n[1] 26.66364\n\n$`6`\n[1] 19.74286\n\n$`8`\n[1] 15.1\n```\n:::\n:::\n\n### Matrix as the output\nThe `map` family include functions that organize the output in different data structures, whose names follow the pattern `map_*`. As we've seen, the `map` function return a list. The following functions will return a vector of a specific kind, e.g. `map_lgl` returns a vector of logical variables, `map_chr` returns a vector of strings. It is also possible to return the the results as data frames by row binding (`map_dfr`) or column binding (`map_dfc`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_dat |> \n  map_dbl(.f = ~mean(.x$mpg)) # returns a vector of doubles\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       4        6        8 \n26.66364 19.74286 15.10000 \n```\n:::\n\n```{.r .cell-code}\nstr_dat |> \n  map_dfr(.f = ~colMeans(.x)) # return a data frame by row binding\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 11\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  26.7     4  105.  82.6  4.07  2.29  19.1 0.909 0.727  4.09  1.55\n2  19.7     6  183. 122.   3.59  3.12  18.0 0.571 0.429  3.86  3.43\n3  15.1     8  353. 209.   3.23  4.00  16.8 0     0.143  3.29  3.5 \n```\n:::\n\n```{.r .cell-code}\nstr_dat |> \n  map_dfc(.f = ~colMeans(.x)) # return a data frame by col binding\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 3\n       `4`     `6`     `8`\n     <dbl>   <dbl>   <dbl>\n 1  26.7    19.7    15.1  \n 2   4       6       8    \n 3 105.    183.    353.   \n 4  82.6   122.    209.   \n 5   4.07    3.59    3.23 \n 6   2.29    3.12    4.00 \n 7  19.1    18.0    16.8  \n 8   0.909   0.571   0    \n 9   0.727   0.429   0.143\n10   4.09    3.86    3.29 \n11   1.55    3.43    3.5  \n```\n:::\n:::\n\n\n\n### Multiple Input\nIt is possible that an operation requires a pair of variables as input. While it is still managable in `map` to achieve this, there are better options provided in `purrr`, specifically `map2` and `pmap`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_avg <- map_dbl(.x = mtcars, .f = mean)\n\nmap2_avg <- map2_dbl(.x = mtcars,\n                     .y = list(weight = 1/nrow(mtcars)),\n                     .f = ~sum(.x*.y))\nidentical(map_avg, map2_avg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\npmap_avg <- pmap_dbl(list(x = mtcars,\n                          y = list(weight = 1/(2*nrow(mtcars))),\n                          z = list(weight2 = 2)),\n                     .f = ~sum(..1*..2*..3))\nidentical(map_avg, pmap_avg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Use element names in pmap\nmtcars$weight <- 1/2\nmtcars$weight2 <-  2\npmap_eg2 <- pmap_dbl(mtcars,\n                     .f = function(mpg, weight, weight2, ...){\n                       mpg * weight * weight2\n                     })\n\nidentical(pmap_eg2, mtcars$mpg)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### No output\nIt is possible that some operations don't need any output during the iteration, e.g. saving the dataset. In this case, `map` will force an output, e.g. `NULL`. One can consider using `walk` instead. The function `walk` behaves exactly the same as `map` but does not output anything. \n\n::: {.cell}\n\n```{.r .cell-code}\ntmp_fldr <- tempdir()\n\n\nmap2(.x = str_dat,\n     .y = 1:length(str_dat),\n     .f = ~saveRDS(.x, \n                   file = paste0(tmp_fldr, \"/\",.y, \".rds\"))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`4`\nNULL\n\n$`6`\nNULL\n\n$`8`\nNULL\n```\n:::\n\n```{.r .cell-code}\n# No output\nwalk2(.x = str_dat,\n      .y = (1:length(str_dat)),\n      .f = ~saveRDS(.x, \n                    file = paste0(tmp_fldr, \"/\",.y, \".rds\"))\n)\n```\n:::\n\n\n## Other functions in `purrr`\n### `reduce` and `accumulate`\n`purrr` also provides functions to summarize a list by a preferred operator, namesly `reduce`. Its variant `accumulate` provides the history of this reduction process.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$weight <- 1/(2*nrow(mtcars))\nmtcars$weight2 <-  2\nreduce_eg <- \n  pmap_dbl(mtcars,\n           .f = function(mpg, weight, weight2, ...){\n             mpg * weight * weight2\n           }) |> \n  reduce(`+`)\n\npmap_dbl(mtcars,\n           .f = function(mpg, weight, weight2, ...){\n             mpg * weight * weight2\n           })|>\n  head() |> # Only show the first 7 operations\n  accumulate(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.656250 1.312500 2.025000 2.693750 3.278125 3.843750\n```\n:::\n:::\n\n\n### Working with list\n\nLet's move to the `purrr` cheatsheet at <https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf>.\n\n# Summary\n* Introduction to functional programming.\n* The R package `purrr` provides a nice interface to functional programming and list manipulation.\n* The function `map` and its aternative `map_*` provide a neat way to iterate over a list or vector with the output in different data structures.\n* The function `map2` and `pmap` allow having more than one list as input.\n* The function `walk` and its alternatives `walk2`, `walk_*` do not provide any output.\n* The functions `reduce` and `accumulate` help to summarize a list with a preferred operator or function.\n\n<iframe src=\"https://giphy.com/embed/VEsfbW0pBu145PPhOi\" width=\"480\" height=\"400\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe>\n\n# Post-lecture materials\n\n::: callout-note\n### Questions\n1. What does `imap` and `iwalk` do? In this lecture note, can you find the one example possible to substitute with `imap` and `iwalk`? Hint: see the sub-section named _No output_\n\n1. Is there any function in the R base package provide nice interface for functional programming? Hint: `?with`, `?within`\n\n2. Can you write a section of code to demonstrate the central limited theorem primarily using the `purrr` package and/or using the R base package?  \n:::\n\n### Additional Resources\n\n::: callout-tip\n-   <https://r4ds.had.co.nz/iteration.html>\n-   <https://www.stat.umn.edu/geyer/8054/notes/functional.html>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}