{
  "hash": "abefecba9250b3c407b69ee37f314c5a",
  "result": {
    "markdown": "---\ntitle: \"Object Oriented Programming\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to S3, S4, or reference class with generics and methods\"\ndate: 2022-11-15\ndraft: true\ncategories: [module 2, week 4, R, functions, programming]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://adv-r.hadley.nz/oo>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://rdpeng.github.io/Biostat776/lecture-object-oriented-programming>\n- <https://adv-r.hadley.nz/oo>\n- <https://www.educative.io/blog/object-oriented-programming>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Recognize the primary object-oriented systems in R: S3, S4, and Reference Classes (RC). \n- Understand the terminology of a **class**, **object**, **method**, **constructor** and **generic**.\n- Be able to create a new S3, S4 or reference class with generics and methods\n\n:::\n\n# Introduction\n\nObject oriented programming is one of the most successful and widespread\nphilosophies of programming and is a cornerstone of many programming languages\nincluding Java, Ruby, Python, and C++. \n\nAt it's core, **object oriented programming** (OOP) is a paradigm that is made up of **classes** and **objects**. \n\nAt a high-level, we use OOP to structure software programs into small, reusable pieces of code blueprints (i.e. **classes**), which are used to create instances of concrete **objects**.\n\nThe blueprint (or **class**) typically represents broad categories, e.g. `bus` or `car` that share **attributes** (e.g. color). The classes specify what attributes you want, but not the actual values for a particular object. However, when you create instances with objects, you are specifying the attributes (e.g. a blue car, a red car, etc). \n\nIn addition, classes can also contain functions, called **methods** available only to objects of that type. These functions are defined within the class and perform some action helpful to that specific type of object. For example, our `car` class may have a method `repaint` that changes the color attribute of our car. This function is only helpful to objects of type `car`, so we declare it within the `car` class thus making it a method.\n\n\n## OOP in R\n\nBase R has three object oriented systems\nbecause the roots of R date back to 1976, when the idea of object orientated\nprogramming was barely [four years old](https://en.wikipedia.org/wiki/Smalltalk).\n\nNew object oriented paradigms were added to R as they were invented, so some of\nthe ideas in R about OOP have gone stale in the years\nsince. It is still important to understand these older systems since a huge\namount of R code is written with them, and they are still useful and interesting!\nLong time object oriented programmers reading this book may find these old ideas\nrefreshing.\n\nThe two older object oriented systems in R are called S3 and S4, and the modern\nsystem is called RC which stands for \"reference classes.\" Programmers who are\nalready familiar with object oriented programming will feel at home using RC.\n\nToday we are going to focus on S3 and S4, but we leave RC for you to review, if you wish. \n\nIn general, you should know and use S3 and this is also the OOP system that is \nmost widely used in R. However, there are different R communities that prioritize \nother OOP systems (e.g. Bioconductor uses mostly S4).\n\n## Object Oriented Principles\n\nOk let's talk about some OOP principles. The first is is the idea of a **class** and an **object**. \n\nThe world is made up of physical objects - the chair you are\nsitting in, the clock next to your bed, the bus you ride every day, etc. Just\nlike the world is full of physical objects, your programs can be made of objects\nas well. \n\nA **class is a blueprint for an object**: it describes the parts of an\nobject, how to make an object, and what the object is able to do. If you were to\nthink about a class for a bus (as in the public buses that roam the roads), this\nclass would describe attributes for the bus like the number of seats on the bus,\nthe number of windows, the color of the bus, the top speed of the bus, \nand the maximum distance the bus can drive on one tank of gas. \n\nBuses, in general, can perform the same actions,\nand these actions are also described in the class: a bus can open and close its\ndoors, the bus can steer, and the accelerator or the brake can be used to slow\ndown or speed up the bus. Each of these actions can be described as a **method**,\nwhich is a **function** that is associated with a particular class. \n\nWe will be using this class in order to create individual bus objects, so we should\nprovide a **constructor**, which is a method where we can specify attributes of\nthe bus as arguments. This constructor method will then return an individual bus\nobject with the attributes that we specified.\n\nYou could also imagine that after making the bus class you might want to make\na special kind of class for a [party bus](https://en.wikipedia.org/wiki/Party_bus).\nParty buses have all of the same attributes and methods as our bus class, but\nthey also have additional attributes and methods like the number of\nrefrigerators, window blinds that can be opened and closed, and smoke machines\nthat can be turned on and off. \n\nInstead of rewriting the entire bus class and\nthen adding new attributes and methods, it is possible for the party bus class\nto **inherit** all of the attributes and methods from the bus class. In this\nframework of inheritance, we talk about the bus class as the super-class of the\nparty bus, and the party bus is the sub-class of the bus. What this relationship\nmeans is that the party bus has all of the same attributes and methods as the\nbus class plus additional attributes and methods.\n\n# S3\n\nConveniently everything in R is an **object**. By \"everything\" I mean every single\n\"thing\" in R including numbers, functions, strings, data frames, lists, etc. \n\nAnd while everything in R is an object, not everything is **object-oriented**.\n\nThis confusion arises because the base objects come from S, and were developed before anyone thought that S might need an OOP system. The tools and nomenclature evolved organically over many years without a single guiding principle.\n\nMost of the time, the distinction between objects and object-oriented objects is not important. But here we need to get into the nitty gritty details so we will use the terms base objects and OO objects to distinguish them.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Everything in R is an object!](https://d33wubrfki0l68.cloudfront.net/5d6b4926530f3da70f16b54dcdf1a55eb8fa3d71/703e0/diagrams/oo-venn.png){fig-align='center' width=60%}\n:::\n:::\n\n\n[[Source](https://adv-r.hadley.nz/base-types.html#introduction-11)]\n\nTo tell the difference between a base and OO object, use `is.object()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A base object:\nis.object(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# An OO object\nis.object(airquality)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\nTechnically, the difference between base and OO objects is that OO objects have a \"class\" attribute:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(1:10, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nattr(airquality, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\nThis can be slightly confusing, but important to note: \nyou can find out the class of an object in R using\nthe `class()` function, but this may or may not have a class attribute. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nclass(\"is in session.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n:::\n\n\n\n## Base types\n\nWhile only OO objects have a class attribute, every object has a base type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\nBase types do not form an OOP system because functions that behave differently for different base types are primarily written in C code that uses switch statements. \n\nThis means that only the R-core team can create new types, and creating a new type is a lot of work because every switch statement needs to be modified to handle a new case. As a consequence, new base types are rarely added. In total, there are [25 different base types](https://adv-r.hadley.nz/base-types.html#base-types-2). \n\nHere are two more base types we have already learned about: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"complex\"\n```\n:::\n:::\n\n\n## OO objects\n\nAt a high-level, an S3 object is a **base type** with at least a **class** attribute. \n\nFor example, take the `factor`. Its base type is the `integer` vector, it has a `class` attribute of \"factor\", and a `levels` attribute that stores the possible levels:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- factor(c(\"a\", \"b\", \"c\"))\ntypeof(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nattributes(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$levels\n[1] \"a\" \"b\" \"c\"\n\n$class\n[1] \"factor\"\n```\n:::\n:::\n\n\nCool. Let's try creating a new class in the S3 system. \n\nIn the S3 system you can arbitrarily assign a class to any object.\nClass assignments can be made using the `structure()` function, or you can\nassign the class using `class()` and `<-`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecial_num_1 <- structure(1, class = \"special_number\")\nclass(special_num_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"special_number\"\n```\n:::\n\n```{.r .cell-code}\nspecial_num_2 <- 2\nclass(special_num_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(special_num_2) <- \"special_number\"\nclass(special_num_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"special_number\"\n```\n:::\n:::\n\n\nAs crazy as this is, it is completely legal R code, but if you want \nto have a better behaved S3 class you should create a constructor which\nreturns an S3 object. The `shape_S3()` function below is a constructor \nthat returns a shape_S3 object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshape_s3 <- function(side_lengths){\n  structure(list(side_lengths = side_lengths), class = \"shape_S3\")\n}\n\nsquare_4 <- shape_s3(c(4, 4, 4, 4))\nclass(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\"\n```\n:::\n\n```{.r .cell-code}\ntriangle_3 <- shape_s3(c(3, 3, 3))\nclass(triangle_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\"\n```\n:::\n:::\n\n\nWe have now made two shape_S3 objects: `square_4` and `triangle_3`, which are both\ninstantiations of the shape_S3 class. \n\nImagine that you wanted to create a **method** (or function)\nthat would return `TRUE` if a shape_S3 object was a square, `FALSE` if a\nshape_S3 object was not a square, and `NA` if the object provided as an\nargument to the method was not a shape_s3 object. \n\nThis can be achieved using R's **generic methods** system. \nA generic method can return different values based depending on the class of \nits input. \n\nFor example `mean()` is a generic method that can find the average \nof a vector of number or it can find the \"average day\" from a vector of dates. \nThe following snippet demonstrates this behavior:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(2, 3, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nmean(c(as.Date(\"2016-09-01\"), as.Date(\"2016-09-03\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-02\"\n```\n:::\n:::\n\n\nNow let's create a generic method for identifying shape_S3 objects that are\nsquares. The creation of every generic method uses the `UseMethod()` function\nin the following way with only slight variations:\n\n```\n[name of method] <- function(x) UseMethod(\"[name of method]\")\n```\n\nLet's call this method `is_square`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_square <- function(x) UseMethod(\"is_square\")\n```\n:::\n\n\nNow we can add the actual function definition for detecting whether or not a\nshape is a square by specifying `is_square.shape_S3`. By putting a dot (`.`)\nand then the name of the class after `is_square`, we can create a method that\nassociates `is_square` with the `shape_S3` class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_square.shape_S3 <- function(x){\n  length(x$side_lengths) == 4 &&\n    x$side_lengths[1] == x$side_lengths[2] &&\n    x$side_lengths[2] == x$side_lengths[3] &&\n    x$side_lengths[3] == x$side_lengths[4]\n}\n\nis_square(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_square(triangle_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nSeems to be working well! We also want `is_square()` to return `NA` when its\nargument is not a shape_S3. We can specify `is_square.default` as a last resort\nif there is not method associated with the object passed to `is_square()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_square.default <- function(x){\n  NA\n}\n\nis_square(\"square\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nis_square(c(1, 1, 1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nLet's try printing `square_4`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$side_lengths\n[1] 4 4 4 4\n\nattr(,\"class\")\n[1] \"shape_S3\"\n```\n:::\n:::\n\n\nDoesn't that look ugly? Lucky for us `print()` is a generic method, so we can\nspecify a print method for the shape_S3 class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.shape_S3 <- function(x){\n  if(length(x$side_lengths) == 3){\n    paste(\"A triangle with side lengths of\", x$side_lengths[1], \n          x$side_lengths[2], \"and\", x$side_lengths[3])\n  } else if(length(x$side_lengths) == 4) {\n    if(is_square(x)){\n      paste(\"A square with four sides of length\", x$side_lengths[1])\n    } else {\n      paste(\"A quadrilateral with side lengths of\", x$side_lengths[1],\n            x$side_lengths[2], x$side_lengths[3], \"and\", x$side_lengths[4])\n    }\n  } else {\n    paste(\"A shape with\", length(x$side_lengths), \"sides.\")\n  }\n}\n\nprint(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A square with four sides of length 4\"\n```\n:::\n\n```{.r .cell-code}\nprint(triangle_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A triangle with side lengths of 3 3 and 3\"\n```\n:::\n\n```{.r .cell-code}\nprint(shape_s3(c(10, 10, 20, 20, 15)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A shape with 5 sides.\"\n```\n:::\n\n```{.r .cell-code}\nprint(shape_s3(c(2, 3, 4, 5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A quadrilateral with side lengths of 2 3 4 and 5\"\n```\n:::\n:::\n\n\nSince printing an object to the console is one of the most common things to do\nin R, nearly every class has an associated print method! To see all of the\nmethods associated with a generic like `print()` use the `methods()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(methods(print), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"print.acf\"     \"print.AES\"     \"print.anova\"   \"print.aov\"    \n [5] \"print.aovlist\" \"print.ar\"      \"print.Arima\"   \"print.arima0\" \n [9] \"print.AsIs\"    \"print.aspell\" \n```\n:::\n:::\n\n\nOne last note on S3 with regard to inheritance. In the previous section we\ndiscussed how a sub-class can inherit attributes and methods from a super-class.\nSince you can assign any class to an object in S3, you can specify a super\nclass for an object the same way you would specify a class for an object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\"\n```\n:::\n\n```{.r .cell-code}\nclass(square_4) <- c(\"shape_S3\", \"square\")\nclass(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\" \"square\"  \n```\n:::\n:::\n\n\nTo check if an object is a sub-class of a specified class you can use the\n`inherits()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninherits(square_4, \"square\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n## Example: S3 Class/Methods for Polygons\n\n\n\n\n\nThe S3 system doesn't have a formal way to define a class but typically, we use a list to define the class and elements of the list serve as data elements.\n\nHere is our definition of a polygon represented using Cartesian coordinates. The class contains an element called `xcoord` and `ycoord` for the x- and y-coordinates, respectively. The `make_poly()` function is the \"constructor\" function for polygon objects. It takes as arguments a numeric vector of x-coordinates and a corresponding numeric vector of y-coordinates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Constructor function for polygon objects\n## x a numeric vector of x coordinates\n## y a numeric vector of y coordinates\nmake_poly <- function(x, y) {\n        if(length(x) != length(y))\n                stop(\"'x' and 'y' should be the same length\")\n        \n        ## Create the \"polygon\" object \n        object <- list(xcoord = x, ycoord = y)\n        \n        ## Set the class name\n        class(object) <- \"polygon\"\n        object\n}\n```\n:::\n\n\nNow that we have a class definition, we can develop some methods for operating on objects from that class. \n\nThe first method that we will define is the `print()` method. The `print()` method should just show some simple information about the object and should not be too verbose---just enough information that the user knows what the object is. \n\nHere the `print()` method just shows the user how many vertices the polygon has. It is a convention for `print()` methods to return the object `x` invisibly using the `invisible()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Print method for polygon objects\n## x an object of class \"polygon\"\n\nprint.polygon <- function(x, ...) {\n        cat(\"a polygon with\", length(x$xcoord), \n            \"vertices\\n\")\n        invisible(x)\n}\n```\n:::\n\n\n\nThe `invisible()` function is useful when it is desired to have functions return values which can be assigned, but which do not print when they are not assigned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These functions both return their argument\n\nf1 <- function(x) x\nf2 <- function(x) invisible(x)\n\nf1(1)  # prints\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nf2(1)  # does not\n```\n:::\n\n\nHowever, when you assign the `f2()` function to an object, it does return the value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- f2(1)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\n\nNext is the `summary()` method. The `summary()` method typically shows a bit more information and may even do some calculations. This `summary()` method computes the ranges of the x- and y-coordinates.\n\nThe typical approach for `summary()` methods is to allow the summary method to compute something, but to *not* print something. The strategy is\n\n1. The `summary()` method returns an object of class \"summary_'class name'\"\n\n2. There is a separate `print()` method for \"summary_'class name'\" objects.\n\nFor example, here is the `summary()` method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Summary method for polygon objects\n## object an object of class \"polygon\"\n\nsummary.polygon <- function(object, ...) {\n        object <- list(rng.x = range(object$xcoord),\n                       rng.y = range(object$ycoord))\n        class(object) <- \"summary_polygon\"\n        object\n}\n```\n:::\n\n\nNote that it simply returns an object of class `summary_polygon`. \n\nNow the corresponding `print()` method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Print method for summary.polygon objects\n## x an object of class \"summary_polygon\"\nprint.summary_polygon <- function(x, ...) {\n        cat(\"x:\", x$rng.x[1], \"-->\", x$rng.x[2], \"\\n\")\n        cat(\"y:\", x$rng.y[1], \"-->\", x$rng.y[2], \"\\n\")\n        invisible(x)\n}\n```\n:::\n\n\nNow we can make use of our new class and methods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Construct a new \"polygon\" object\nx <- make_poly(1:4, c(1, 5, 2, 1))\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"xcoord\" \"ycoord\"\n\n$class\n[1] \"polygon\"\n```\n:::\n:::\n\n\nWe can use the `print()` to see what the object is.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na polygon with 4 vertices\n```\n:::\n:::\n\n\nAnd we can use the `summary()` method to get a bit more information about the object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- summary(x)\nclass(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"summary_polygon\"\n```\n:::\n\n```{.r .cell-code}\nprint(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx: 1 --> 4 \ny: 1 --> 5 \n```\n:::\n:::\n\n\nBecause of auto-printing we can just call the `summary()` method and let the results auto-print.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx: 1 --> 4 \ny: 1 --> 5 \n```\n:::\n:::\n\n\nFrom here, we could build other methods for interacting with our `polygon` object. For example, it may make sense to define a `plot()` method or maybe methods for intersecting two polygons together.\n\n\n# S4\n\nThe S4 system is slightly more restrictive than S3, but it's similar in many\nways. To create a new class in S4 you need to use the `setClass()` function.\nYou need to specify two or three arguments for this function: `Class` which\nis the name of the class as a string, `slots`, which is a named list of\nattributes for the class with the class of those attributes specified, and\noptionally `contains` which includes the super-class of they class you are\nspecifying (if there is a super-class). Take look at the class definition for\na `bus_S4` and a `party_bus_S4` below:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass(Class = \"bus_S4\",\n         slots = list(n_seats = \"numeric\", \n                      top_speed = \"numeric\",\n                      current_speed = \"numeric\",\n                      brand = \"character\"))\nsetClass(Class = \"party_bus_S4\",\n         slots = list(n_subwoofers = \"numeric\",\n                      smoke_machine_on = \"logical\"),\n         contains = \"bus_S4\")\n```\n:::\n\n\nNow that we have created the `bus_S4` and the `party_bus_S4` classes we can\ncreate bus objects using the `new()` function. The `new()` function's arguments\nare the name of the class and values for each \"slot\" in our S4 object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_bus <- new(\"bus_S4\", n_seats = 20, top_speed = 80, \n              current_speed = 0, brand = \"Volvo\")\nmy_bus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class \"bus_S4\"\nSlot \"n_seats\":\n[1] 20\n\nSlot \"top_speed\":\n[1] 80\n\nSlot \"current_speed\":\n[1] 0\n\nSlot \"brand\":\n[1] \"Volvo\"\n```\n:::\n\n```{.r .cell-code}\nmy_party_bus <- new(\"party_bus_S4\", n_seats = 10, top_speed = 100,\n                    current_speed = 0, brand = \"Mercedes-Benz\", \n                    n_subwoofers = 2, smoke_machine_on = FALSE)\nmy_party_bus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class \"party_bus_S4\"\nSlot \"n_subwoofers\":\n[1] 2\n\nSlot \"smoke_machine_on\":\n[1] FALSE\n\nSlot \"n_seats\":\n[1] 10\n\nSlot \"top_speed\":\n[1] 100\n\nSlot \"current_speed\":\n[1] 0\n\nSlot \"brand\":\n[1] \"Mercedes-Benz\"\n```\n:::\n:::\n\n\nYou can use the `@` operator to access the slots of an S4 object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_bus@n_seats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n\n```{.r .cell-code}\nmy_party_bus@top_speed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n:::\n\n\nThis is essentially the same as using the `$` operator with a list or an\nenvironment.\n\nS4 classes use a generic method system that is similar to S3 classes. In order\nto implement a new generic method you need to use the `setGeneric()` function\nand the `standardGeneric()` function in the following way:\n\n```\nsetGeneric(\"new_generic\", function(x){\n  standardGeneric(\"new_generic\")\n})\n```\n\nLet's create a generic function called `is_bus_moving()` to see if a bus_S4\nobject is in motion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetGeneric(\"is_bus_moving\", function(x){\n  standardGeneric(\"is_bus_moving\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"is_bus_moving\"\n```\n:::\n:::\n\n\nNow we need to actually define the function, which we can to with\n`setMethod()`. The `setMethod()` functions takes as arguments the name of the\nmethod as a string (or `f`), the method signature (`signature`),\nwhich specifies the class of each argument for the method, \nand then the function definition of the method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetMethod(f = \"is_bus_moving\",\n          signature = c(x = \"bus_S4\"),\n          definition = function(x){\n                          x@current_speed > 0\n                      }\n          )\n\nis_bus_moving(my_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nmy_bus@current_speed <- 1\nis_bus_moving(my_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIn addition to creating your own generic methods, you can also create a method\nfor your new class from an existing generic. \n\nFirst, use the `setGeneric()` function with the name of the existing method \nyou want to use with your class, \nand then use the `setMethod()` function like in the previous example. Let's\nmake a `print()` method for the bus_S4 class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetGeneric(\"print\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"print\"\n```\n:::\n\n```{.r .cell-code}\nsetMethod(f = \"print\",\n          signature = c(x = \"bus_S4\"),\n          definition = function(x){\n            paste(\"This\", x@brand, \"bus is traveling at a speed of\", x@current_speed)\n          })\n\nprint(my_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This Volvo bus is traveling at a speed of 1\"\n```\n:::\n\n```{.r .cell-code}\nprint(my_party_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This Mercedes-Benz bus is traveling at a speed of 0\"\n```\n:::\n:::\n\n\n\n# Reference Classes\n\n<details> <summary> Click here to learn about reference classes (RC).</summary>\n\nWith reference classes we leave the world of R's old object oriented systems\nand enter the philosophies of other prominent object oriented programming\nlanguages. We can use the `setRefClass()` function to define a class' fields,\nmethods, and super-classes. Let's make a reference class that represents a\nstudent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nStudent <- setRefClass(\"Student\",\n                      fields = list(name = \"character\",\n                                    grad_year = \"numeric\",\n                                    credits = \"numeric\",\n                                    id = \"character\",\n                                    courses = \"list\"),\n                      methods = list(\n                        hello = function(){\n                          paste(\"Hi! My name is\", name)\n                        },\n                        add_credits = function(n){\n                          credits <<- credits + n\n                        },\n                        get_email = function(){\n                          paste0(id, \"@jhu.edu\")\n                        }\n                      ))\n```\n:::\n\n\nTo recap: we have created a class definition called `Student`, which defines the\nstudent class. This class has five fields and three methods. To create a Student\nobject use the `new()` method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrooke <- Student$new(name = \"Brooke\", grad_year = 2019, credits = 40,\n                    id = \"ba123\", courses = list(\"Ecology\", \"Calculus III\"))\nstephanie <- Student$new(name = \"Stephanie\", grad_year = 2021, credits = 10,\n                    id = \"shicks456\", courses = list(\"Puppetry\", \"Elementary Algebra\"))\n```\n:::\n\n\nYou can access the fields and methods of each object using the `$` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrooke$credits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 40\n```\n:::\n\n```{.r .cell-code}\nstephanie$hello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi! My name is Stephanie\"\n```\n:::\n\n```{.r .cell-code}\nstephanie$get_email()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shicks456@jhu.edu\"\n```\n:::\n:::\n\n\nMethods can change the state of an object, for instance in the case of the\n`add_credits()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrooke$credits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 40\n```\n:::\n\n```{.r .cell-code}\nbrooke$add_credits(4)\nbrooke$credits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 44\n```\n:::\n:::\n\n\nNotice that the `add_credits()` method uses the complex assignment\noperator (`<<-`). You need to use this operator if you want to modify one \nof the fields of an object with a method. You'll learn more about this operator\nin the Expressions & Environments section.\n\nReference classes can inherit from other classes by specifying the `contains`\nargument when they're defined. Let's create a sub-class of Student called\nGrad_Student which includes a few extra features:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGrad_Student <- setRefClass(\"Grad_Student\",\n                            contains = \"Student\",\n                            fields = list(thesis_topic = \"character\"),\n                            methods = list(\n                              defend = function(){\n                                paste0(thesis_topic, \". QED.\")\n                              }\n                            ))\n\njeff <- Grad_Student$new(name = \"Jeff\", grad_year = 2021, credits = 8,\n                    id = \"jl55\", courses = list(\"Fitbit Repair\", \n                                                \"Advanced Base Graphics\"),\n                    thesis_topic = \"Batch Effects\")\n\njeff$defend()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Batch Effects. QED.\"\n```\n:::\n:::\n\n\n</details>\n\n# Summary\n\n- R has three object oriented systems: S3, S4, and Reference Classes. \n- Reference Classes are the most similar to classes and objects in other\nprogramming languages.\n- Classes are blueprints for an object.\n- Objects are individual instances of a class.\n- Methods are functions that are associated with a particular class.\n- Constructors are methods that create objects.\n- Everything in R is an object.\n- S3 is a liberal object oriented system that allows you to assign a class to\nany object.\n- S4 is a more strict object oriented system that build upon ideas in S3.\n- Reference Classes are a modern object oriented system that is similar to Java,\nC++, Python, or Ruby.\n\n\n\n\n\n# Post-lecture materials\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://adv-r.hadley.nz/oo>\n- <https://rdpeng.github.io/Biostat776/lecture-object-oriented-programming>\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}