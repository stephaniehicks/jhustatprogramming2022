{
  "hash": "1641f54b036198be30b7925f92b4e580",
  "result": {
    "markdown": "---\ntitle: \"Object Oriented Programming\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to S3, S4, or reference class with generics and methods\"\ndate: 2022-11-15\ncategories: [module 2, week 4, R, functions, programming]\n---\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://adv-r.hadley.nz/oo>\n2. <https://adv-r.hadley.nz/base-types>\n3. <https://adv-r.hadley.nz/s3>\n4. <https://adv-r.hadley.nz/s4>\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://rdpeng.github.io/Biostat776/lecture-object-oriented-programming>\n- <https://adv-r.hadley.nz/oo>\n- <https://www.educative.io/blog/object-oriented-programming>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Recognize the primary object-oriented systems in R: S3, S4, R6, and Reference Classes (RC). \n- Understand the terminology of a **class**, **object**, **method**, **constructor** and **generic**.\n- Be able to create a new S3 or S4 with generics and methods\n\n:::\n\n# Introduction\n\nObject oriented programming is one of the most successful and widespread\nphilosophies of programming and is a cornerstone of many programming languages\nincluding Java, Ruby, Python, and C++. \n\nAt it's core, **object oriented programming** (OOP) is a paradigm that is made up of **classes** and **objects**. \n\nAt a high-level, we use OOP to structure software programs into small, reusable pieces of code blueprints (i.e. **classes**), which are used to create instances of concrete **objects**.\n\nThe blueprint (or **class**) typically represents broad categories, e.g. `bus` or `car` that share **attributes** (e.g. color) (or **fields**). \n\n- The **classes specify what attributes you want**, but not the actual values for a particular object. \n- However, when you **create instances with objects**, you are specifying the attributes (e.g. a blue car, a red car, etc). \n\nIn addition, classes can also contain functions, called **methods** available only to objects of that type. \n\n- These functions are **defined within the class** and perform some action helpful to that specific type of object. \n- For example, our `car` class may have a method `repaint` that changes the color attribute of our car. \n- This function is only helpful to objects of type `car`, so we declare it within the `car` class thus making it a method.\n\n\n## OOP in R\n\n**Base R has three object oriented systems**, because the roots of R \ndate back to 1976, when the idea of object orientated programming was \nbarely [four years old](https://en.wikipedia.org/wiki/Smalltalk).\n\n**New object oriented paradigms** were added to R as they were invented, \nand they exist in their own R packages.\n\n:::{.callout-tip}\n\n### Why is OOP hard in R? \n\nOOP is a little more challenging in R than in other languages because:\n\n1. There are **multiple OOP systems to choose from**. Here, I will focus on the following three: **S3**, **R6**, and **S4**. \n  - S3 and S4 are provided by base R (two older OOP languages). \n  - R6 is provided by the R6 package, and is similar to the \n  - Reference Classes, or RC for short, from base R. Programmers who are\nalready familiar with object oriented programming will feel at home using RC. \n\n2. There is **disagreement about the relative importance** of the OOP systems. Hadley Wickham thinks S3 is most important, followed by R6, then S4. Others believe that S4 is most important (e.g. Bioconductor community), followed by RC, and that S3 should be avoided. This means that different R communities use different systems.\n\n3. S3 and S4 use **generic function OOP** which is rather different from the **encapsulated OOP** used by most languages popular today (the exception is Julia which also uses generic function OOP) (more on these later). Basically, while the underlying ideas of OOP are the same across languages, their expressions are rather different. This means that you can not immediately transfer your existing OOP skills to R.\n\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\nGenerally in R, functional programming is much more important than object-oriented programming, because you typically solve complex problems by decomposing them into simple functions, not simple objects. \n\n:::\n\nThis lesson focuses on the mechanics of OOP, not its effective use, and it may be challenging to fully understand if you have not done object-oriented programming before. \n\n## sloop\n\nBefore we go on I want to introduce the `sloop` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sloop)\n```\n:::\n\n\nThe `sloop` package (think \"sail the seas of OOP\") provides a number of helpers that fill in missing pieces in base R. The first of these is `sloop::otype()`. It makes it easy to figure out the OOP system used by a wild-caught object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\notype(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"base\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\notype(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)\notype(mle_obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S4\"\n```\n:::\n:::\n\n\n\n\n## OOP systems\n\nDifferent people use OOP terms in different ways, so this section provides a quick overview of **important vocabulary**. The explanations are necessarily compressed, but we will come back to these ideas multiple times.\n\nThe main reason to use OOP is **polymorphism** (literally: many shapes). \n\n- **Polymorphism** means that a developer can consider a function’s interface separately from its implementation, making it possible to use the same function form for different types of input. \n- This is closely related to the idea of **encapsulation**: the user doesn’t need to worry about details of an object because they are encapsulated behind a standard interface.\n\nTo be concrete, polymorphism is what allows `summary()` to produce different outputs for numeric and factor variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(penguins$bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  32.10   39.23   44.45   43.92   48.50   59.60       2 \n```\n:::\n\n```{.r .cell-code}\nsummary(penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Adelie Chinstrap    Gentoo \n      152        68       124 \n```\n:::\n:::\n\n\nYou could imagine `summary()` containing a series of if-else statements, but that would mean only the original author could add new implementations. An OOP system makes it possible for any developer to extend the interface with implementations for new types of input.\n\nTo **be more precise**, OO systems call the type of an object its **class**, and an implementation for a specific class is called a **method**. Roughly speaking, \n\n- a class defines what an object *is* and \n- methods describe what that object can *do*\n\nThe class defines the **fields** (or **attributes**), the data possessed by every instance of that class. Classes are organised in a hierarchy so that if a method does not exist for one class, its parent's method is used, and the child is said to **inherit** behavior. \n\n:::{.callout-tip}\n\n### Example\n\n- An ordered factor inherits from a regular factor.\n- A generalized linear model inherits from a linear model. \n\n:::\n\nThe process of finding the correct method given a class is called **method dispatch**.\n\n:::{.callout-tip}\n\n### Two paradigms of OOP\n\nThe two main paradigms of OOP differ in how methods and classes are related. We will call these paradigms **encapsulated** and **functional**:\n\n1. In **encapsulated OOP**, methods belong to objects or classes, and method calls typically look like `object.method(arg1, arg2)`. This is called encapsulated because the object encapsulates both data (with fields) and behavior (with methods), and is the paradigm found in most popular languages.\n\n2. In **functional OOP**, methods belong to generic functions, and method calls look like ordinary function calls: `generic(object, arg2, arg3)`. This is called functional because from the outside it looks like a regular function call, and internally the components are also functions.\n\n:::\n\nWith this terminology in hand, we can now talk precisely about the different OO systems available in R.\n\n\n## OOP principles\n\nOk let's talk more about some OOP principles. The first is is the idea of a **class** and an **object**. \n\nThe world is made up of physical objects - the chair you are\nsitting in, the clock next to your bed, the bus you ride every day, etc. Just\nlike the world is full of physical objects, your programs can be made of objects\nas well. \n\nA **class is a blueprint for an object**: it describes the parts of an\nobject, how to make an object, and what the object is able to do. \n\n:::{.callout-tip}\n\n### Example\n\nIf you were to think about a class for a bus (as in the public buses that roam the roads), this class would describe **attributes** for the bus like \n\n- the number of seats on the bus \n- the number of windows\n- the color of the bus \n- the top speed of the bus\n- the maximum distance the bus can drive on one tank of gas\n\n:::\n\nA **method is a function that is associated with a class** to perform an action. \n\n:::{.callout-tip}\n\n### Example\n\nBuses, in general, can perform the same actions, and these actions are also described in the class: \n\n- a bus can open and close its doors\n- the bus can steer\n- the accelerator or the brake can be used to slow down or speed up the bus\n\n:::\n\nA **constructor is a method to specify attributes of the class** to create a object with the specific attributes that we specified. \n\n:::{.callout-tip}\n\n### Example\n\nWe will use the `bus` class in order to create individual `bus` objects. \n\nTo do this, we will create a constructor method for the `bus` class to return an individual bus\nobject with the attributes that we specified.\n\n:::\n\nIf we want to make a new class that has all the same attributes and methods as an existing class, but also has additional attributes, we do not want to rewrite the entire class, but rather we want to **define a new class that inherits from the original class**. \n\n:::{.callout-tip}\n\n### Example\n\nImagine that after making the `bus` class you might want to make\na special kind of class for a [party bus](https://en.wikipedia.org/wiki/Party_bus).\n\nThe `party_bus` class has all of the same attributes and methods as our `bus` class, but\nthey also has additional attributes and methods like \n\n- the number of refrigerators\n- window blinds that can be opened and closed\n- smoke machines that can be turned on and off\n\n:::\n\nIn this framework of inheritance, we talk about the bus class as the \nsuper-class of the party bus, and the party bus is the sub-class of the bus. \n\nWhat this relationship means is that the party bus has all of the same attributes \nand methods as the bus class plus additional attributes and methods.\n\n\n## OOP in R (v2)\n\nBase R provides three OOP systems: S3, S4, and reference classes (RC):\n\n1. **S3** is R’s first OOP system, and is described in *Statistical Models in S*. S3 is an informal implementation of functional OOP and relies on common conventions rather than ironclad guarantees. This makes it easy to get started with, providing a low cost way of solving many simple problems.\n\n2. **S4** is a formal and rigorous rewrite of S3, and was introduced in *Programming with Data*. It requires more upfront work than S3, but in return provides more guarantees and greater encapsulation. S4 is implemented in the base **methods** package, which is always installed with R.\n\n:::{.callout-tip}\n\n### Pro-tip\n\nYou might wonder if S1 and S2 exist. They don’t: S3 and S4 were named according to the versions of S that they accompanied. The first two versions of S didn’t have any OOP framework. \n\n:::\n\n3. **RC** implements encapsulated OO. RC objects are a special type of S4 objects that are also **mutable** (i.e., instead of using R’s usual copy-on-modify semantics, they can be modified in place). This makes them harder to reason about, but allows them to solve problems that are difficult to solve in the functional OOP style of S3 and S4.\n\n\n\n\n\n# S3\n\nS3 allows your functions to **return rich results with user-friendly display** and **programmer-friendly internals**. \n\n**S3 is used throughout base R**, so it’s important to master if you want to extend base R functions to work with new types of input.\n\nConveniently everything in R is an **object**. By \"everything\" I mean every single\n\"thing\" in R including numbers, functions, strings, data frames, lists, etc. \n\nAnd while everything in R is an object, not everything is **object-oriented**.\n\nThis confusion arises because the base objects come from S, and were developed before anyone thought that S might need an OOP system. The tools and nomenclature evolved organically over many years without a single guiding principle.\n\nMost of the time, the distinction between objects and object-oriented objects is not important. But here we need to get into the nitty gritty details so we will use the terms **base objects** and **OO objects** to distinguish them.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Everything in R is an object!](https://d33wubrfki0l68.cloudfront.net/5d6b4926530f3da70f16b54dcdf1a55eb8fa3d71/703e0/diagrams/oo-venn.png){fig-align='center' width=60%}\n:::\n:::\n\n\n[[Source](https://adv-r.hadley.nz/base-types.html#introduction-11)]\n\nTo tell the difference between a base and OO object, use `is.object()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A base object:\nis.object(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# An OO object\nis.object(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nTechnically, the difference between base and OO objects is that OO objects have a \"class\" attribute:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(1:10, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nattributes(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nattr(mtcars, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nattributes(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n\n$row.names\n [1] \"Mazda RX4\"           \"Mazda RX4 Wag\"       \"Datsun 710\"         \n [4] \"Hornet 4 Drive\"      \"Hornet Sportabout\"   \"Valiant\"            \n [7] \"Duster 360\"          \"Merc 240D\"           \"Merc 230\"           \n[10] \"Merc 280\"            \"Merc 280C\"           \"Merc 450SE\"         \n[13] \"Merc 450SL\"          \"Merc 450SLC\"         \"Cadillac Fleetwood\" \n[16] \"Lincoln Continental\" \"Chrysler Imperial\"   \"Fiat 128\"           \n[19] \"Honda Civic\"         \"Toyota Corolla\"      \"Toyota Corona\"      \n[22] \"Dodge Challenger\"    \"AMC Javelin\"         \"Camaro Z28\"         \n[25] \"Pontiac Firebird\"    \"Fiat X1-9\"           \"Porsche 914-2\"      \n[28] \"Lotus Europa\"        \"Ford Pantera L\"      \"Ferrari Dino\"       \n[31] \"Maserati Bora\"       \"Volvo 142E\"         \n\n$class\n[1] \"data.frame\"\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\nThis can be slightly confusing, but important to note: \n\nYou can **find out the class of an object** in R using the `class()` function, \nbut the **object may or may not have a class attribute**. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nclass(\"is in session.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n:::\n\n\n:::\n\n\n## Base types\n\nWhile only OO objects have a class attribute, every object has a base type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\n**Base types do not form an OOP system** because functions that behave differently for different base types are primarily written in C code that uses switch statements. \n\nThis means that only the R-core team can create new types, and creating a new type is a lot of work because every switch statement needs to be modified to handle a new case. As a consequence, new base types are rarely added. \n\n:::{.callout-tip}\n\n### Pro-tip\n\nIn total, there are [25 different base types](https://adv-r.hadley.nz/base-types.html#base-types-2).\n\n:::\n\nHere are some more base types we have already learned about: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"NULL\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"complex\"\n```\n:::\n:::\n\n\n## OO objects\n\nAt a high-level, an S3 object is a **base type** with at least a **class** attribute. \n\n:::{.callout-tip}\n\n### Example\n\nTake the `factor`. Its base type is the `integer` vector, it has a `class` attribute of \"factor\", and a `levels` attribute that stores the possible levels:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- factor(c(\"a\", \"b\", \"c\"))\ntypeof(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nattributes(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$levels\n[1] \"a\" \"b\" \"c\"\n\n$class\n[1] \"factor\"\n```\n:::\n:::\n\n\n:::\n\n\n:::{.callout-note}\n\n### Question\n\nLet's consider the `penguins` data frame. \n\n- What is it's base type? \n- What is it's `class` attribute? \n- What other attributes does it have? \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it here\n```\n:::\n\n\n:::\n\nCool. Let's try creating a new class in the S3 system. \n\nIn the S3 system you can arbitrarily assign a class to any object.\nClass assignments can be made using the `structure()` function, or you can\nassign the class using `class()` and `<-`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecial_num_1 <- structure(1, class = \"special_number\")\nspecial_num_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\nattr(,\"class\")\n[1] \"special_number\"\n```\n:::\n\n```{.r .cell-code}\nclass(special_num_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"special_number\"\n```\n:::\n:::\n\n\n:::{.callout-note}\n\n### Question\n\nLet's assign the number 2 to `special_num_2` and look at the class of `special_num_2`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n### try it here\n```\n:::\n\n\nWhat's happened here? \n\n:::\n\n\n:::{.callout-note}\n\n### Question\n\nNext, let's assign \"special_number\" to the class of `special_num_2`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(special_num_2) <- \"special_number\"\nclass(special_num_2)\nspecial_num_2\n```\n:::\n\n\nWhat's happening here? \n\n:::\n\nAs crazy as this is, it is completely legal R code, but if you want \nto have a better behaved S3 class you should create a constructor which\nreturns an S3 object. \n\n\n### Create a constructor called `shape_s3()`\n\n:::{.callout-tip}\n\n### Example \n\nConsider the `shape_s3()` function below, which is a constructor \nthat returns a `shape_S3` object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshape_s3 <- function(side_lengths){\n  structure(list(side_lengths = side_lengths), class = \"shape_S3\")\n}\n\nsquare_4 <- shape_s3(c(4, 4, 4, 4))\nclass(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\"\n```\n:::\n\n```{.r .cell-code}\ntriangle_3 <- shape_s3(c(3, 3, 3))\nclass(triangle_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\"\n```\n:::\n:::\n\n\n\nWe have now made two `shape_S3` objects: `square_4` and `triangle_3`, which are both\ninstantiations of the `shape_S3` class. \n\n:::\n\nImagine that you wanted to create a **method** (or function)\nthat would return `TRUE` if a `shape_S3` object was a square, `FALSE` if a\n`shape_S3` object was not a square, and `NA` if the object provided as an\nargument to the method was not a `shape_S3` object. \n\nThis can be achieved using R's **generic methods** system. \nA generic method can return different values based depending on the class of \nits input. \n\n\n:::{.callout-tip}\n\n### Example\n\nFor example, `mean()` is a generic method that can find the average \nof a vector of number or it can find the \"average day\" from a vector of dates. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(2, 3, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nmean(c(as.Date(\"2016-09-01\"), as.Date(\"2016-09-03\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2016-09-02\"\n```\n:::\n:::\n\n\n:::\n\n\n### Create a generic method called `is_square()`\n\nNow, let's **create a generic method** for identifying `shape_S3` objects that are\nsquares. \n\n:::{.callout-tip}\n\n### Step 1: use `UseMethod()`\n\nFirst, the creation of every generic method uses the `UseMethod()` function\nin the following way with only slight variations:\n\n```\n[name of method] <- function(x) UseMethod(\"[name of method]\")\n```\n\nLet's call this method `is_square`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_square <- function(x) UseMethod(\"is_square\")\n```\n:::\n\n\n:::\n\n\n:::{.callout-tip}\n\n### Step 2: Define what's inside the method\n\nNext, we add the **actual definition** for the function to detect whether or not a\nshape is a square by specifying `is_square.shape_S3`. \n\nBy putting a dot (`.`)\nand then the name of the class after `is_square`, we can create a method that\nassociates `is_square` with the `shape_S3` class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_square.shape_S3 <- function(x){\n  length(x$side_lengths) == 4 &&\n    x$side_lengths[1] == x$side_lengths[2] &&\n    x$side_lengths[2] == x$side_lengths[3] &&\n    x$side_lengths[3] == x$side_lengths[4]\n}\n\nis_square(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_square(triangle_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n:::\n\nSeems to be working well! \n\nWe also want `is_square()` to return `NA` when its\nargument is not a `shape_S3`. \n\nWe can specify `is_square.default` as a last resort\nif there is not method associated with the object passed to `is_square()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_square.default <- function(x){\n  NA\n}\n\nis_square(\"square\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nis_square(c(1, 1, 1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nLet's try printing `square_4`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$side_lengths\n[1] 4 4 4 4\n\nattr(,\"class\")\n[1] \"shape_S3\"\n```\n:::\n:::\n\n\nDoesn't that look ugly? \n\n### Create a generic method `print()` for `shape_S3` class\n\nLucky for us `print()` is a generic method, so we can\nspecify a print method for the `shape_S3` class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.shape_S3 <- function(x){\n  if(length(x$side_lengths) == 3){\n    paste(\"A triangle with side lengths of\", x$side_lengths[1], \n          x$side_lengths[2], \"and\", x$side_lengths[3])\n  } else if(length(x$side_lengths) == 4) {\n    if(is_square(x)){\n      paste(\"A square with four sides of length\", x$side_lengths[1])\n    } else {\n      paste(\"A quadrilateral with side lengths of\", x$side_lengths[1],\n            x$side_lengths[2], x$side_lengths[3], \"and\", x$side_lengths[4])\n    }\n  } else {\n    paste(\"A shape with\", length(x$side_lengths), \"sides.\")\n  }\n}\n\nprint(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A square with four sides of length 4\"\n```\n:::\n\n```{.r .cell-code}\nprint(triangle_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A triangle with side lengths of 3 3 and 3\"\n```\n:::\n\n```{.r .cell-code}\nprint(shape_s3(c(10, 10, 20, 20, 15)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A shape with 5 sides.\"\n```\n:::\n\n```{.r .cell-code}\nprint(shape_s3(c(2, 3, 4, 5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A quadrilateral with side lengths of 2 3 4 and 5\"\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\nSince **printing an object to the console** is one of the most common things to do\nin R, nearly every class has an associated print method! \n\nTo see all of the methods associated with a generic like `print()` use the `methods()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(methods(print))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 260\n```\n:::\n\n```{.r .cell-code}\nhead(methods(print), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"print.acf\"     \"print.AES\"     \"print.anova\"   \"print.aov\"    \n [5] \"print.aovlist\" \"print.ar\"      \"print.Arima\"   \"print.arima0\" \n [9] \"print.AsIs\"    \"print.aspell\" \n```\n:::\n:::\n\n\n:::\n\n### Inheritance\n\nOne last note on S3 with regard to **inheritance**. \n\nIn the previous section we\ndiscussed how **a sub-class can inherit attributes and methods from a super-class**.\n\nSince you can assign any class to an object in S3, you can **specify a super\nclass** for an object the same way you would specify a class for an object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\"\n```\n:::\n\n```{.r .cell-code}\nclass(square_4) <- c(\"shape_S3\", \"square\")\nclass(square_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shape_S3\" \"square\"  \n```\n:::\n:::\n\n\nTo **check if an object is a sub-class of a specified class** you can use the\n`inherits()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninherits(square_4, \"square\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n## Example: S3 Class/Methods for Polygons\n\n\n\n\n\nThe S3 system doesn't have a formal way to define a class but typically, we use a list to define the class and elements of the list serve as data elements.\n\nHere is our definition of a **polygon represented using Cartesian coordinates**. \n\n- The class contains an element called `xcoord` and `ycoord` for the x- and y-coordinates, respectively. \n- The `make_poly()` function is the \"constructor\" function for polygon objects. It takes as arguments a numeric vector of x-coordinates and a corresponding numeric vector of y-coordinates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Constructor function for polygon objects\n## x a numeric vector of x coordinates\n## y a numeric vector of y coordinates\nmake_poly <- function(x, y) {\n        if(length(x) != length(y))\n                stop(\"'x' and 'y' should be the same length\")\n        \n        ## Create the \"polygon\" object \n        object <- list(xcoord = x, ycoord = y)\n        \n        ## Set the class name\n        class(object) <- \"polygon\"\n        object\n}\n```\n:::\n\n\nNow that we have a class definition, we can **develop some methods for operating on objects from that class**. \n\nThe first method that we will define is the `print()` method. The `print()` method should just show some simple information about the object and should not be too verbose---just enough information that the user knows what the object is. \n\nHere the `print()` method just shows the user how many vertices the polygon has. \n\nIt is a convention for `print()` methods to **return the object `x` invisibly** using the `invisible()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Print method for polygon objects\n## x an object of class \"polygon\"\n\nprint.polygon <- function(x, ...) {\n        cat(\"a polygon with\", length(x$xcoord), \n            \"vertices\\n\")\n        invisible(x)\n}\n```\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\nThe `invisible()` function is useful when it is **desired to have functions return values which can be assigned, but which do not print when they are not assigned**.\n\n:::\n\n:::{.callout-tip}\n\n### Example\n\nThese functions both return their argument\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(x) x\nf2 <- function(x) invisible(x)\n\nf1(1)  # prints\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nf2(1)  # does not print\n```\n:::\n\n\nHowever, when you assign the `f2()` function to an object, it does return the value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- f2(1)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n:::\n\nNext is the `summary()` method.\n\nThe `summary()` method **typically shows a bit more information and may even do some calculations**, but does **not** print something. The general strategy of `summary()` methods is\n\n1. The `summary()` method returns an object of class `\"summary_'class name'\"`\n2. There is a separate `print()` method for `\"summary_'class name'\"` objects.\n\nFor example, here is a `summary()` method for `polygon` objects that computes the ranges of the x- and y-coordinates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## object an object of class \"polygon\"\n\nsummary.polygon <- function(object, ...) {\n        object <- list(rng.x = range(object$xcoord),\n                       rng.y = range(object$ycoord))\n        class(object) <- \"summary_polygon\"\n        object\n}\n```\n:::\n\n\n:::{.callout-tip}\n\n### Note\n\nThe `summary` method simply returns an object of class `summary_polygon`. \n\n:::\n\nNow the corresponding `print()` method for `summary.polygon` objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Note: x an object of class \"summary_polygon\"\nprint.summary_polygon <- function(x, ...) {\n        cat(\"x:\", x$rng.x[1], \"-->\", x$rng.x[2], \"\\n\")\n        cat(\"y:\", x$rng.y[1], \"-->\", x$rng.y[2], \"\\n\")\n        invisible(x)\n}\n```\n:::\n\n\nNow we can make use of our new `polygon` class and methods (`summary()` and `print()`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Construct a new \"polygon\" object\nx <- make_poly(1:4, c(1, 5, 2, 1))\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"xcoord\" \"ycoord\"\n\n$class\n[1] \"polygon\"\n```\n:::\n:::\n\n\nWe can use the `print()` to see what the object is.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na polygon with 4 vertices\n```\n:::\n:::\n\n\nAnd we can use the `summary()` method to get a bit more information about the object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- summary(x)\nclass(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"summary_polygon\"\n```\n:::\n\n```{.r .cell-code}\nprint(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx: 1 --> 4 \ny: 1 --> 5 \n```\n:::\n:::\n\n\nBecause of auto-printing we can just call the `summary()` method and let the results auto-print.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx: 1 --> 4 \ny: 1 --> 5 \n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### What next? \n\nFrom here, we could build other methods for interacting with our `polygon` object. \n\nFor example, it may make sense to define a `plot()` method or maybe methods for intersecting two polygons together.\n\n:::\n\n\n# S4\n\n\nS4 is a **rigorous system that forces you to think carefully about program design**.\n\nIt’s particularly **well-suited for building large systems** that evolve over time and will receive contributions from many programmers. This is why it is used by the Bioconductor project, so another reason to learn S4 is to equip you to contribute to that project.\n\nThe S4 system is **slightly more restrictive than S3**, but it's similar in many\nways. \n\n## Constructors in S4\n\n- To create a new class in S4 you need to use the `setClass()` function. \n- You need to specify two (or three arguments) for this function: \n  - `Class` which is the name of the class as a string\n  - `slots`, which is a named list of attributes for the class with the class of those attributes specified\n  - (optionally) `contains`, which includes the super-class of they class you are\nspecifying (if there is a super-class)\n\nTake look at the class definition for a `bus_S4` and a `party_bus_S4` below:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass(Class = \"bus_S4\",\n         slots = list(n_seats = \"numeric\", \n                      top_speed = \"numeric\",\n                      current_speed = \"numeric\",\n                      brand = \"character\"))\nsetClass(Class = \"party_bus_S4\",\n         slots = list(n_subwoofers = \"numeric\",\n                      smoke_machine_on = \"logical\"),\n         contains = \"bus_S4\")\n```\n:::\n\n\nNow that we have created the `bus_S4` and the `party_bus_S4` classes we can\ncreate bus objects using the `new()` function. The `new()` function's arguments\nare the name of the class and values for each \"slot\" in our S4 object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_bus <- new(\"bus_S4\", n_seats = 20, top_speed = 80, \n              current_speed = 0, brand = \"Volvo\")\nmy_bus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class \"bus_S4\"\nSlot \"n_seats\":\n[1] 20\n\nSlot \"top_speed\":\n[1] 80\n\nSlot \"current_speed\":\n[1] 0\n\nSlot \"brand\":\n[1] \"Volvo\"\n```\n:::\n\n```{.r .cell-code}\nmy_party_bus <- new(\"party_bus_S4\", n_seats = 10, top_speed = 100,\n                    current_speed = 0, brand = \"Mercedes-Benz\", \n                    n_subwoofers = 2, smoke_machine_on = FALSE)\nmy_party_bus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class \"party_bus_S4\"\nSlot \"n_subwoofers\":\n[1] 2\n\nSlot \"smoke_machine_on\":\n[1] FALSE\n\nSlot \"n_seats\":\n[1] 10\n\nSlot \"top_speed\":\n[1] 100\n\nSlot \"current_speed\":\n[1] 0\n\nSlot \"brand\":\n[1] \"Mercedes-Benz\"\n```\n:::\n:::\n\n\nYou can use the `@` operator to access the slots of an S4 object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_bus@n_seats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n\n```{.r .cell-code}\nmy_party_bus@top_speed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n:::\n\n\nThis is essentially the same as using the `$` operator with a list or an\nenvironment.\n\n## Methods in S4\n\nS4 classes use a generic method system that is similar to S3 classes. In order\nto implement a new generic method you need to use the `setGeneric()` function\nand the `standardGeneric()` function in the following way:\n\n```\nsetGeneric(\"new_generic\", function(x){\n  standardGeneric(\"new_generic\")\n})\n```\n\nLet's create a generic function called `is_bus_moving()` to see if a bus_S4\nobject is in motion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetGeneric(\"is_bus_moving\", function(x){\n  standardGeneric(\"is_bus_moving\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"is_bus_moving\"\n```\n:::\n:::\n\n\nNow, we need to actually define the function, which we can to with\n`setMethod()`. \n\nThe `setMethod()` functions takes as arguments \n\n- the **name of the method as a string** (or `f`)\n- the **method signature** (`signature`), which specifies the class of each argument for the method\n- the **function definition** of the method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetMethod(f = \"is_bus_moving\",\n          signature = c(x = \"bus_S4\"),\n          definition = function(x){\n                          x@current_speed > 0\n                      }\n          )\n\nis_bus_moving(my_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nmy_bus@current_speed <- 1\nis_bus_moving(my_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIn addition to creating your own generic methods, you can also create a method\nfor your new class from an existing generic. \n\nFirst, use the `setGeneric()` function with the name of the existing method \nyou want to use with your class, \nand then use the `setMethod()` function like in the previous example. Let's\nmake a `print()` method for the `bus_S4` class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetGeneric(\"print\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"print\"\n```\n:::\n\n```{.r .cell-code}\nsetMethod(f = \"print\",\n          signature = c(x = \"bus_S4\"),\n          definition = function(x){\n            paste(\"This\", x@brand, \"bus is traveling at a speed of\", x@current_speed)\n          })\n\nprint(my_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This Volvo bus is traveling at a speed of 1\"\n```\n:::\n\n```{.r .cell-code}\nprint(my_party_bus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This Mercedes-Benz bus is traveling at a speed of 0\"\n```\n:::\n:::\n\n\n# Reference Classes\n\n<details> <summary> Click here to learn about reference classes (RC).</summary>\n\nWith reference classes we leave the world of R's old object oriented systems\nand enter the philosophies of other prominent object oriented programming\nlanguages. We can use the `setRefClass()` function to define a class' fields,\nmethods, and super-classes. Let's make a reference class that represents a\nstudent:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nStudent <- setRefClass(\"Student\",\n                      fields = list(name = \"character\",\n                                    grad_year = \"numeric\",\n                                    credits = \"numeric\",\n                                    id = \"character\",\n                                    courses = \"list\"),\n                      methods = list(\n                        hello = function(){\n                          paste(\"Hi! My name is\", name)\n                        },\n                        add_credits = function(n){\n                          credits <<- credits + n\n                        },\n                        get_email = function(){\n                          paste0(id, \"@jhu.edu\")\n                        }\n                      ))\n```\n:::\n\n\nTo recap: we have created a class definition called `Student`, which defines the\nstudent class. This class has five fields and three methods. To create a Student\nobject use the `new()` method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrooke <- Student$new(name = \"Brooke\", grad_year = 2019, credits = 40,\n                    id = \"ba123\", courses = list(\"Ecology\", \"Calculus III\"))\nstephanie <- Student$new(name = \"Stephanie\", grad_year = 2021, credits = 10,\n                    id = \"shicks456\", courses = list(\"Puppetry\", \"Elementary Algebra\"))\n```\n:::\n\n\nYou can access the fields and methods of each object using the `$` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrooke$credits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 40\n```\n:::\n\n```{.r .cell-code}\nstephanie$hello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi! My name is Stephanie\"\n```\n:::\n\n```{.r .cell-code}\nstephanie$get_email()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shicks456@jhu.edu\"\n```\n:::\n:::\n\n\nMethods can change the state of an object, for instance in the case of the\n`add_credits()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrooke$credits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 40\n```\n:::\n\n```{.r .cell-code}\nbrooke$add_credits(4)\nbrooke$credits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 44\n```\n:::\n:::\n\n\nNotice that the `add_credits()` method uses the complex assignment\noperator (`<<-`). You need to use this operator if you want to modify one \nof the fields of an object with a method. You'll learn more about this operator\nin the Expressions & Environments section.\n\nReference classes can inherit from other classes by specifying the `contains`\nargument when they're defined. Let's create a sub-class of Student called\nGrad_Student which includes a few extra features:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGrad_Student <- setRefClass(\"Grad_Student\",\n                            contains = \"Student\",\n                            fields = list(thesis_topic = \"character\"),\n                            methods = list(\n                              defend = function(){\n                                paste0(thesis_topic, \". QED.\")\n                              }\n                            ))\n\njeff <- Grad_Student$new(name = \"Jeff\", grad_year = 2021, credits = 8,\n                    id = \"jl55\", courses = list(\"Fitbit Repair\", \n                                                \"Advanced Base Graphics\"),\n                    thesis_topic = \"Batch Effects\")\n\njeff$defend()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Batch Effects. QED.\"\n```\n:::\n:::\n\n\n</details>\n\n# Summary\n\n- R has three object oriented systems: S3, S4, and Reference Classes. \n- Reference Classes are the most similar to classes and objects in other\nprogramming languages.\n- Classes are blueprints for an object.\n- Objects are individual instances of a class.\n- Methods are functions that are associated with a particular class.\n- Constructors are methods that create objects.\n- Everything in R is an object.\n- S3 is a liberal object oriented system that allows you to assign a class to\nany object.\n- S4 is a more strict object oriented system that build upon ideas in S3.\n- Reference Classes are a modern object oriented system that is similar to Java,\nC++, Python, or Ruby.\n\n\n\n\n\n# Post-lecture materials\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://adv-r.hadley.nz/oo>\n- <https://rdpeng.github.io/Biostat776/lecture-object-oriented-programming>\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}