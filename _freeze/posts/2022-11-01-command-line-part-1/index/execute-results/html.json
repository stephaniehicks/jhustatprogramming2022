{
  "hash": "2806c4fba915ca6117301a1015a30cd3",
  "result": {
    "markdown": "---\ntitle: \"Data science at the command-line (Part 1)\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to the command-line for data analysis (part 1)\"\ndate: 2022-11-01\ndraft: true\ncategories: [module 1, week 2, command-line]\neditor_options: \n  chunk_output_type: inline\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  Add here.\n2.  Add here.\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   [Software Carpentry: The Unix Shell](https://swcarpentry.github.io/shell-novice)\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Understand what is a command shell and why would use one.\n-   Explain how the shell relates to the keyboard, the screen, the operating system, and users' programs.\n-   Explain when and why command-line interfaces should be used instead of graphical interfaces.\n:::\n\n# Introduction\n\nWe we use interact with computers, we often do so with a keyboard and mouse, touch screen interfaces, or using speech recognition systems.\n\nThe most widely used way to interact with personal computers is called a **graphical user interface** (GUI). With a GUI, we give instructions by clicking a mouse and using menu-driven interactions.\n\nThe problem with only working with GUIs is that while the visual aid of a GUI makes it intuitive to learn, this way of delivering instructions to a computer scales very poorly.\n\n::: callout-note\n### Example\n\nImagine the following task: for a literature search, you have to\n\n1.  Copy the third line of one thousand text files in one thousand different directories\n2.  Paste the lines into a single file.\n\nUsing a GUI, you would not only be clicking at your desk for several hours, but you could potentially also commit an error in the process of completing this repetitive task.\n:::\n\nThis is where we take advantage of the **Unix shell**.\n\nThe Unix shell is both\n\n1.  A **command-line interface** (CLI)\n2.  A **scripting language**\n\nThis allows such repetitive tasks to be done automatically and fast. Using the shell, the task in the literature example can be accomplished in seconds.\n\n## The Shell\n\nThe **shell is a program** (or environment) where users can **type commands** and the commands can be executed. Another way of thinking about it is, a shell provides an **interface between the user and the UNIX system**.\n\n::: callout-note\n### Types of shells\n\n-   **Bash** (Bourne Again SHell). The most popular Unix shell is Bash (the Bourne Again SHell --- so-called because it's derived from a shell written by Stephen Bourne). Bash is the default shell on most modern implementations of Unix and in most packages that provide Unix-like tools for Windows.\n-   **Zsh** (Z SHell). Zsh is built on top of bash with some additional features including providing the user with more flexibility by providing various features such as plug-in support, better customization, theme support, spelling correction, etc. Zsh is the default shell for macOS and Kali Linux.\n:::\n\nThe **grammar of a shell** allows you to combine existing tools into powerful pipelines and handle large volumes of data automatically. Sequences of commands can be written into a script, improving the reproducibility of workflows.\n\nIn addition, the command line is often the easiest way to interact with remote machines and supercomputers.\n\n-   Familiarity with the shell is near essential to run a variety of specialized tools and resources including high-performance computing systems.\n-   As clusters and cloud computing systems become more popular for scientific data crunching, being able to interact with the shell is becoming a necessary skill.\n\nLet's get started.\n\n## Opening the shell\n\nWhen the shell is first opened, you are presented with a prompt, indicating that the shell is waiting for input.\n\n``` {.bash filename=\"Bash\"}\n$\n```\n\nThe shell typically uses `$` as the prompt, but may use a different symbol (for the purposes of the rest of the lecture, I will omit the `$`).\n\n::: callout-important\n1.  When typing commands in the shell, **do not type the `$`**, only the commands that follow it.\n2.  After you type a command, you have to **press the Enter key** to execute it.\n:::\n\nThe prompt is followed by a text cursor, a character that indicates the position where your typing will appear.\n\nSo let's try our first command, `ls` which is short for listing files. With R, we know how to do this with `list.files()` function in base R: \n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nlist.files()\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"index.qmd\"       \"index.rmarkdown\"\n```\n:::\n:::\n\n\nThis command will list the contents of the current directory where the lecture is located. In RStudio, we can write a bash code block like this: \n\n```{{bash}}\nls\n```\n\nand the executed code block is this: \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nindex.qmd\nindex.rmarkdown\n```\n:::\n:::\n\n\nIf the shell can't find a program whose name is the command you typed, it will print an error message such as:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nks\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nError in running command bash\n```\n:::\n:::\n\n\n\\$ ks ks: command not found This might happen if the command was mis-typed or if the program corresponding to that command is not installed.\n\n``` {.bash filename=\"Hi\"}\n# render single document (always executes code)\nquarto render document.qmd\n\n# render project subdirectory (always executes code)\nquarto render articles\n```\n\n``` {{r}}\nmean(1:5)\n```\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Add here.\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   Add here.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}