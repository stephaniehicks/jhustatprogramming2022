{
  "hash": "06db81ead57e691836168de0246d5572",
  "result": {
    "markdown": "---\ntitle: \"Advanced command-line tools\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Doing more powerful things on the command-line\"\ndate: 2022-11-03\ncategories: [module 1, week 2, command-line]\n---\n\n::: {.cell}\n\n:::\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://swcarpentry.github.io/shell-novice>\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://swcarpentry.github.io/shell-novice/04-pipefilter>\n- <https://swcarpentry.github.io/shell-novice/05-loop>\n- <https://swcarpentry.github.io/shell-novice/06-script>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Redirect a command’s output to a file with redirect operators (`>`, `>>`).\n- Construct command pipelines with two or more stages with the pipe operator (`|`).\n- Write a loop that applies one or more commands separately to each file in a set of files.\n- Explain why spaces should not be used in file names inside of loops.\n\n:::\n\n# Pipes\n\n## Capturing output from commands\n\nIn this section, we will continue to explore how to use pipes to **re-direct output** from to the terminal and write it to a file. \n\n:::{.callout-tip}\n\n### Dataset \n\nThe dataset we will use is a folder that contains six files describing some simple organic molecules. The `.pdb` extension indicates that these files are in Protein Data Bank format, a simple text format that specifies the type and position of each atom in the molecule.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls proteins\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncubane.pdb\nethane.pdb\nmethane.pdb\noctane.pdb\npentane.pdb\npropane.pdb\n```\n:::\n:::\n\n\n:::\n\nLet's count the lines in one of the files `cubane.pdb` using the `wc` command (**w**ord **c**ount): \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwc -l proteins/cubane.pdb\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n      20 proteins/cubane.pdb\n```\n:::\n:::\n\n\n\n\n:::{.callout-note}\n\n### Question\n\nUsing wildcard (`*`), list out all the number of lines in each `.pdb` file in the `protein` directory\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n## try it out \n\n```\n:::\n\n\n:::\n\nThis is useful information, but all of that output gets printed to the screen and then it's gone. Let's try saving the output to a file with the redirection `>` operator: \n\n:::{.callout-tip}\n\n### Redirection operator\n\nIn the previous lecture, we learned that if we wanted to redirect that output from printing to the terminal and write to a file, we use the `>` operator like so (`command > [file] `) where on the left side is output gets piped into a file on the right side. \n\n:::\n\n:::{.callout-note}\n\n### Question \n\nWrite the commands for the followings tasks: \n\n1. Using the `>` redirect operator, pipe the output from our example above to a file called `lengths.txt`. \n2. Print the file contents in `length.txt` to the screen.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n## try it out \n\n```\n:::\n\n\n:::\n\n## Appending data to a file \n\nIn general, it is a **very bad idea** to try redirecting the output of a command that **operates on a file to the same file**. \n\nFor example:\n\n```{.bash filename=\"Bash\"}\nsort -n lengths.txt > lengths.txt\n```\n\nDoing something like this may give you incorrect results and/or delete the contents of `lengths.txt`.\n\nAn alternative is another type of redirect operator (`>>`), which is used to **append to a file** (`command >> [file]`). \n\nLet's try this out. \n\n:::{.callout-tip}\n\n### Example\n\nNow test the commands below to reveal the difference between the two operators\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho hello > testfile01.txt\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho hello >> testfile02.txt\n```\n:::\n\n\n**Task**: Try executing each command twice in a row and then examining the output files. What happened? \n\n:::\n\nOK let's clean up our space before we move on\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nrm testfile01.txt testfile02.txt\n```\n:::\n\n\n## Passing output to another command\n\nAnother operator is the vertical bar (`|`) (or **pipe operator**) which is used between two commands to pass the output from one command as input to another command (`[first] | [second]`).\n\n:::{.callout-tip}\n\n### Example\n\nLet's sort the rows in `lengths.txt` in a numeric order and then **pipe** the output into another command to show only the first row. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat lengths.txt\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n      20 proteins/cubane.pdb\n      12 proteins/ethane.pdb\n       9 proteins/methane.pdb\n      30 proteins/octane.pdb\n      21 proteins/pentane.pdb\n      15 proteins/propane.pdb\n     107 total\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nsort -n lengths.txt | head -n 1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n       9 proteins/methane.pdb\n```\n:::\n:::\n\n\n:::\n\n:::{.callout-note}\n\n### Question \n\nLet's practice using the pipe operator and combine three commands together. Write the following commands and pipe the output with the `|` operator. \n\nUsing the `*.pdb` files in the `protein` folder: \n\n1. Count the number of lines in each each `*.pdb` file. \n2. Sort the lines numerically in an ascending order. \n3. Show the first line of the output. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\n## try it out\n\n```\n:::\n\n\n\n:::\n\n\n# Loops\t\n\n**Loops** are a programming construct which allow us to **repeat a command** or set of commands **for each item in a list**.\n\n- As such they are **key to productivity improvements through automation**. \n- Similar to wildcards and tab completion, **using loops also reduces the amount of typing required** (and hence reduces the number of typing mistakes).\n\nSuppose we have several hundred genome data files ending in `.dat` and our goal is to extract a piece of information from each file. \n\n:::{.callout-tip}\n\n### Dataset \n\nThe dataset we will use is a folder that only has 3 example files (`basilisk.dat`, `minotaur.dat`, and `unicorn.dat`), but the principles can be applied to many many more files at once.\n\nThe structure of these files is the same. On the first three lines: \n\n- the common name, \n- classification, and \n- updated date \n\nThe DNA sequences are given in the following lines within each file. Let’s look at the files:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nhead -n 5 basilisk.dat minotaur.dat unicorn.dat\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n==> basilisk.dat <==\nCOMMON NAME: basilisk\nCLASSIFICATION: basiliscus vulgaris\nUPDATED: 1745-05-02\nCCCCAACGAG\nGAAACAGATC\n\n==> minotaur.dat <==\nCOMMON NAME: minotaur\nCLASSIFICATION: bos hominus\nUPDATED: 1765-02-17\nCCCGAAGGAC\nCGACATCTCT\n\n==> unicorn.dat <==\nCOMMON NAME: unicorn\nCLASSIFICATION: equus monoceros\nUPDATED: 1738-11-24\nAGCCGGGTCG\nCTTTACCTTA\n```\n:::\n:::\n\n\n:::\n\nHere, we would like to **print out the classification for each species** (given on the second line of each file). \n\nOne way to do this is for each file, we could use the command `head -n 2` and pipe this to `tail -n 1`. \n\n## Loop basics\n\nAnother way to do this is to use a loop to solve this problem, but first let’s look at the general form of a `for` loop, using the pseudo-code below:\n\n```{.bash filename=\"Bash\"}\nfor thing in list_of_things\ndo\n    operation_using $thing    # Indentation within the loop is not required, but aids legibility\ndone\n```\n\nand we can apply this to our example like this:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    head -n 2 $filename | tail -n 1\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nCLASSIFICATION: basiliscus vulgaris\nCLASSIFICATION: bos hominus\nCLASSIFICATION: equus monoceros\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip #1\n\n1. When using variables it is also possible to put the names into curly braces to clearly delimit the variable name: `$filename` is equivalent to `${filename}`, but is different from `${file}name`. You may find this notation in other people’s programs.\n\n:::\n\n:::{.callout-tip}\n\n### Pro-tip #2\n\n2. We have called the variable in this loop `filename` in order to make its purpose clearer to human readers. The shell itself doesn’t care what the variable is called; if we wrote this loop with `x`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nfor x in basilisk.dat minotaur.dat unicorn.dat\ndo\n    head -n 2 $x | tail -n 1\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nCLASSIFICATION: basiliscus vulgaris\nCLASSIFICATION: bos hominus\nCLASSIFICATION: equus monoceros\n```\n:::\n:::\n\n\n:::\n\n:::{.callout-tip}\n\n### Pro-tip #3\n\n3. Spaces are used to separate the elements of the list that we are going to loop over. If one of those elements contains a space character, we need to surround it with quotes, and do the same thing to our loop variable.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor x in \"spooky ghost\" \"scary monster\" \"creepy spider\"\ndo\n   echo $x\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nspooky ghost\nscary monster\ncreepy spider\n```\n:::\n:::\n\n\n:::\n\n:::{.callout-tip}\n\n### Pro-tip #4\n\n4. There are other types of loops including \n\n- The `for` loop: executes the given commands over a series of defined number of iterations\n- The `while` loop: executes the given commands until the given condition changes from true to false\n- The `until` loop: executes the given commands until a given condition becomes true\n- The `select` loop: easy way to create a numbered menu from which users can select options. It is useful when you need to ask the user to choose one or more items from a list of choices.\n\n:::\n\n\n:::{.callout-note}\n\n### Question \n\nUsing the six files in the `proteins` folder, let's predict what the output of these loops are. \n\n```{.bash}\ncd proteins\nfor datafile in *.pdb\ndo\n    ls *.pdb\ndone\n```\n\n\n```{.bash}\ncd proteins\nfor datafile in *.pdb\ndo\n    ls $datafile\ndone\n```\n\n\n```{.bash}\ncd proteins\nfor datafile in c*\ndo\n    ls $datafile\ndone\n```\n\n```{.bash}\ncd proteins\nfor datafile in *c*\ndo\n    ls $datafile\ndone\n```\n\n:::\n\n\n\n## Naming files\n\nYou can also use the variables in `for` loops to name files or folders. \n\nFor example, let's say we want to save a version of the original files in the `creatures` folder, naming the copies `original-basilisk.dat` and `original-unicorn.dat`, etc. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nfor filename in *.dat\ndo\n    cp $filename original-$filename\ndone\n\nls *.dat\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nbasilisk.dat\nminotaur.dat\noriginal-basilisk.dat\noriginal-minotaur.dat\noriginal-unicorn.dat\nunicorn.dat\n```\n:::\n:::\n\n\nThis loop runs the `cp` command once for each filename. The first time, when `$filename` expands to `basilisk.dat`, the shell executes:\n\n```{.bash filename=\"Bash\"}\ncp basilisk.dat original-basilisk.dat\n```\n\nand so on. Finally, let's clean up our copies\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nrm creatures/original-*\nls creatures/*\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncreatures/basilisk.dat\ncreatures/minotaur.dat\ncreatures/unicorn.dat\n```\n:::\n:::\n\n\n\n# Basics of bash scripting\n\nWe are finally ready to see what makes the shell such a powerful programming environment. \n\nWe are going to take the **commands we repeat frequently** and **save them in files** so that we can re-run all those operations again later by typing a single command. \n\nFor historical reasons, a bunch of commands saved in a file is usually called a **shell script**, but make no mistake: these are actually small programs.\n\nNot only will writing shell scripts make your work faster — you won't have to retype the same commands over and over again — it will also make it more accurate (fewer chances for typos) and more reproducible.\n\n## Create a `.sh` file\n\nLet's start by going back to `proteins/` and creating a new file, `middle.sh` which will become our shell script:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd proteins\ntouch middle.sh\n```\n:::\n\n\nWe can open the file and simply insert the following line:\n\n```{.bash}\nhead -n 15 octane.pdb | tail -n 5\n```\n\nThis is a variation on the pipe we constructed earlier: \n\n- it selects lines 11-15 of the file `octane.pdb`. \n\n:::{.callout-tip}\n\n### Note\n\nWe are not running it as a command just yet: we are putting the commands in a file.\n\n:::\n\nWe can see that the directory `proteins/` now contains a file called `middle.sh`.\n\nOnce we have saved the file, we can ask the shell to execute the commands it contains. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd proteins\nbash middle.sh\n```\n:::\n\n\n## File arguements\n\nWhat if we want to **select lines from an arbitrary file**? \n\nWe could edit `middle.sh` each time to change the filename, but that would probably take longer than typing the command out again in the shell and executing it with a new file name. \n\nInstead, let's edit `middle.sh` and make it more versatile:\n\n- Replace the text `octane.pdb` with the special variable called `$1`:\n\n```{.bash}\nhead -n 15 \"$1\" | tail -n 5\n```\n\n:::{.callout-tip}\n\n### Note \nInside a shell script, `$1` means 'the first filename (or other argument) on the command line'.\n\n::: \n\nWe can now run our script like this:\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd proteins\nbash middle.sh octane.pdb\n```\n:::\n\n\n\nor on a different file like this:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd proteins\nbash middle.sh pentane.pdb\n```\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip: double-quotes around arguments\n\nFor the same reason that we put the loop variable inside double-quotes, in case the filename happens to contain any spaces, we surround `$1` with double-quotes.\n\n:::\n\n\nCurrently, we need to edit `middle.sh` each time we want to adjust the range of lines that is returned. \n\nLet's fix that by configuring our script to instead **use three command-line arguments**. \n\n- After the first command-line argument (`$1`), each additional argument that we provide will be accessible via the special variables `$1`, `$2`, `$3`, which refer to the first, second, third command-line arguments, respectively.\n\n\n:::{.callout-note}\n\n### Question\n\nKnowing about `$1`, `$2`, `$3`, let's modify `middle.sh` such that we can use additional arguments to define the range of lines to be passed to `head` and `tail` respectively. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\n## try it out\n\n```\n:::\n\n\n- By changing the arguments to our command we can change our script’s behaviour:\n\n:::\n\n\nThis works, but it may take the next person who reads middle.sh a moment to figure out what it does. We can improve our script by adding some comments at the top of the file:\n\n```{.bash}\n# Select lines from the middle of a file.\n# Usage: bash middle.sh filename end_line num_lines\nhead -n \"$2\" \"$1\" | tail -n \"$3\"\n```\n\n:::{.callout-tip}\n\n### Note \n\n- A comment starts with a `#` character and runs to the end of the line. \n- The computer ignores comments, but they are invaluable for helping people (including your future self) understand and use scripts. \n- The only caveat is that each time you modify the script, you should check that the comment is still accurate: an explanation that sends the reader in the wrong direction is worse than none at all.\n\n:::\n\nFinally, let's clean up our space\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd proteins\nrm middle.sh\n```\n:::\n\n\n# Secure shell protocol\n\nThe **Secure Shell Protocol** (SSH) is a tool you can use to connect and authenticate to remote servers and services (e.g. GitHub, JHPCE, etc). \n\nWith **SSH keys**, you can connect to GitHub without supplying your username and personal access token at each visit. You can also use an SSH key to sign commits.\n\n## Overview \n\nThe SSH protocol **uses encryption to secure the connection** between **a client** and **a server**.\n\nAll user authentication, commands, output, and file transfers are encrypted to protect against attacks in the network. \n\nFor details of how the SSH protocol works, see the [protocol page](https://www.ssh.com/academy/ssh/protocol). To understand the SSH File Transfer Protocol, see the [SFTP page](https://www.ssh.com/academy/ssh/sftp).\n\n![](../../images/ssh_protocol.png)\n\nYou can read more about setting up your SSH keys to connect to JHPCE here: \n\n- <https://jhpce.jhu.edu/knowledge-base/authentication/ssh-key-setup>\n\n- **Demo connecting to JHPCE via `ssh`**\n\n\nYou can read more about setting up your SSH keys to connect to GitHub here: \n\n- <https://docs.github.com/en/authentication/connecting-to-github-with-ssh>\n\n\n# Post-lecture materials\n\n:::{.callout-note}\n\n### Next steps\n\nIf you haven't already done it yet, follow the directions in the link above and set up your SSH keys for password-less connection to interact with GitHub. \n\n:::\n\n\n### Additional Resources\n\n::: callout-tip\n\n- Practice your command line knowledge with [Command Challenge](https://cmdchallenge.com/).\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}