{
  "hash": "1f94a9b7de34f628c601d9a1221b9249",
  "result": {
    "markdown": "---\ntitle: \"Advanced command-line tools\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Doing more powerful things on the command-line\"\ndate: 2022-11-03\ncategories: [module 1, week 2, command-line]\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://swcarpentry.github.io/shell-novice>\n2. \n3. \n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://swcarpentry.github.io/shell-novice/04-pipefilter>\n- <https://swcarpentry.github.io/shell-novice/05-loop>\n- <https://swcarpentry.github.io/shell-novice/06-script>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Redirect a command’s output to a file with redirect operators (`>`, `>>`).\n- Construct command pipelines with two or more stages with the pipe operator (`|`).\n- Write a loop that applies one or more commands separately to each file in a set of files.\n- Explain why spaces should not be used in file names inside of loops.\n\n:::\n\n# Pipes\n\n## Capturing output from commands\n\nIn this section, we will continue to explore how to use pipes to **re-direct output** from to the terminal and write it to a file. \n\n:::{.callout-tip}\n\n### Dataset \n\nThe dataset we will use is a folder that contains six files describing some simple organic molecules. The `.pdb` extension indicates that these files are in Protein Data Bank format, a simple text format that specifies the type and position of each atom in the molecule.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nls proteins\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncubane.pdb\nethane.pdb\nmethane.pdb\noctane.pdb\npentane.pdb\npropane.pdb\n```\n:::\n:::\n\n\n:::\n\nLet's count the lines in one of the files `cubane.pdb` using the `wc` command (**w**ord **c**ount): \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwc -l proteins/cubane.pdb\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n      20 proteins/cubane.pdb\n```\n:::\n:::\n\n\n\n\n:::{.callout-note}\n\n### Question\n\nUsing wildcard (`*`), list out all the number of lines in each `.pdb` file in the `protein` directory\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n## try it out \n\n```\n:::\n\n\n:::\n\nThis is useful information, but all of that output gets printed to the screen and then it's gone. Let's try saving the output to a file with the redirection `>` operator: \n\n:::{.callout-tip}\n\n### Redirection operator\n\nIn the previous lecture, we learned that if we wanted to redirect that output from printing to the terminal and write to a file, we use the `>` operator like so (`command > [file] `) where on the left side is output gets piped into a file on the right side. \n\n:::\n\n:::{.callout-note}\n\n### Question \n\nWrite the commands for the followings tasks: \n\n1. Using the `>` redirect operator, pipe the output from our example above to a file called `lengths.txt`. \n2. Print the file contents in `length.txt` to the screen.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n## try it out \n\n```\n:::\n\n\n:::\n\n## Appending data to a file \n\nIn general, it is a **very bad idea** to try redirecting the output of a command that **operates on a file to the same file**. \n\nFor example:\n\n```{.bash filename=\"Bash\"}\nsort -n lengths.txt > lengths.txt\n```\n\nDoing something like this may give you incorrect results and/or delete the contents of `lengths.txt`.\n\nAn alternative is another type of redirect operator (`>>`), which is used to **append to a file** (`command >> [file]`). \n\nLet's try this out. \n\n:::{.callout-tip}\n\n### Example\n\nNow test the commands below to reveal the difference between the two operators\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho hello > testfile01.txt\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\necho hello >> testfile02.txt\n```\n:::\n\n\n**Task**: Try executing each command twice in a row and then examining the output files. What happened? \n\n:::\n\nOK let's clean up our space before we move on\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nrm testfile01.txt testfile02.txt\n```\n:::\n\n\n## Passing output to another command\n\nAnother operator is the vertical bar (`|`) (or **pipe operator**) which is used between two commands to pass the output from one command as input to another command (`[first] | [second]`).\n\n:::{.callout-tip}\n\n### Example\n\nLet's sort the rows in `lengths.txt` in a numeric order and then **pipe* the output into another command to show only the first row. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat lengths.txt\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n      20 proteins/cubane.pdb\n      12 proteins/ethane.pdb\n       9 proteins/methane.pdb\n      30 proteins/octane.pdb\n      21 proteins/pentane.pdb\n      15 proteins/propane.pdb\n     107 total\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nsort -n lengths.txt | head -n 1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n       9 proteins/methane.pdb\n```\n:::\n:::\n\n\n:::\n\n:::{.callout-note}\n\n### Question \n\nLet's practice using the pipe operator and combine three commands together. Write the following commands and pipe the output with the `|` operator. \n\nUsing the `*.pdb` files in the `protein` folder: \n\n1. Count the number of lines in each each `*.pdb` file. \n2. Sort the lines numerically in an ascending order. \n3. Show the first line of the output. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\n## try it out\n\n```\n:::\n\n\n\n:::\n\n\n# Loops\t\n\n**Loops** are a programming construct which allow us to **repeat a command** or set of commands **for each item in a list**.\n\n- As such they are **key to productivity improvements through automation**. \n- Similar to wildcards and tab completion, **using loops also reduces the amount of typing required** (and hence reduces the number of typing mistakes).\n\nSuppose we have several hundred genome data files ending in `.dat` and our goal is to extract a piece of information from each file. \n\n:::{.callout-tip}\n\n### Dataset \n\nThe dataset we will use is a folder that only has 3 example files (`basilisk.dat`, `minotaur.dat`, and `unicorn.dat`), but the principles can be applied to many many more files at once.\n\nThe structure of these files is the same. On the first three lines: \n\n- the common name, \n- classification, and \n- updated date \n\nThe DNA sequences are given in the following lines within each file. Let’s look at the files:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nhead -n 5 basilisk.dat minotaur.dat unicorn.dat\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n==> basilisk.dat <==\nCOMMON NAME: basilisk\nCLASSIFICATION: basiliscus vulgaris\nUPDATED: 1745-05-02\nCCCCAACGAG\nGAAACAGATC\n\n==> minotaur.dat <==\nCOMMON NAME: minotaur\nCLASSIFICATION: bos hominus\nUPDATED: 1765-02-17\nCCCGAAGGAC\nCGACATCTCT\n\n==> unicorn.dat <==\nCOMMON NAME: unicorn\nCLASSIFICATION: equus monoceros\nUPDATED: 1738-11-24\nAGCCGGGTCG\nCTTTACCTTA\n```\n:::\n:::\n\n\n:::\n\nHere, we would like to **print out the classification for each species** (given on the second line of each file). \n\nOne way to do this is for each file, we could use the command `head -n 2` and pipe this to `tail -n 1`. \n\n## Loop basics\n\nAnother way to do this is to use a loop to solve this problem, but first let’s look at the general form of a `for` loop, using the pseudo-code below:\n\n```{.bash filename=\"Bash\"}\nfor thing in list_of_things\ndo\n    operation_using $thing    # Indentation within the loop is not required, but aids legibility\ndone\n```\n\nand we can apply this to our example like this:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nfor filename in basilisk.dat minotaur.dat unicorn.dat\ndo\n    head -n 2 $filename | tail -n 1\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nCLASSIFICATION: basiliscus vulgaris\nCLASSIFICATION: bos hominus\nCLASSIFICATION: equus monoceros\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\n1. When using variables it is also possible to put the names into curly braces to clearly delimit the variable name: `$filename` is equivalent to `${filename}`, but is different from `${file}name`. You may find this notation in other people’s programs.\n\n2. We have called the variable in this loop `filename` in order to make its purpose clearer to human readers. The shell itself doesn’t care what the variable is called; if we wrote this loop with `x`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nfor x in basilisk.dat minotaur.dat unicorn.dat\ndo\n    head -n 2 $x | tail -n 1\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nCLASSIFICATION: basiliscus vulgaris\nCLASSIFICATION: bos hominus\nCLASSIFICATION: equus monoceros\n```\n:::\n:::\n\n\n3. Spaces are used to separate the elements of the list that we are going to loop over. If one of those elements contains a space character, we need to surround it with quotes, and do the same thing to our loop variable.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor x in \"spooky ghost\" \"scary monster\" \"creepy spider\"\ndo\n   echo $x\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nspooky ghost\nscary monster\ncreepy spider\n```\n:::\n:::\n\n\n4. There are other types of loops including \n\n- The `for` loop: executes the given commands over a series of defined number of iterations\n- The `while` loop: executes the given commands until the given condition changes from true to false\n- The `until` loop: executes the given commands until a given condition becomes true\n- The `select` loop: easy way to create a numbered menu from which users can select options. It is useful when you need to ask the user to choose one or more items from a list of choices.\n\n:::\n\n\n:::{.callout-note}\n\n### Question \n\nUsing the six files in the `proteins` folder, let's predict what the output of these loops are. \n\n```{.bash}\ncd proteins\nfor datafile in *.pdb\ndo\n    ls *.pdb\ndone\n```\n\n\n```{.bash}\ncd proteins\nfor datafile in *.pdb\ndo\n    ls $datafile\ndone\n```\n\n\n```{.bash}\ncd proteins\nfor datafile in c*\ndo\n    ls $datafile\ndone\n```\n\n```{.bash}\ncd proteins\nfor datafile in *c*\ndo\n    ls $datafile\ndone\n```\n\n:::\n\n\n\n## Naming files\n\nYou can also use the variables in `for` loops to name files or folders. \n\nFor example, let's say we want to save a version of the original files in the `creatures` folder, naming the copies `original-basilisk.dat` and `original-unicorn.dat`, etc. \n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd creatures\nfor filename in *.dat\ndo\n    cp $filename original-$filename\ndone\n\nls *.dat\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nbasilisk.dat\nminotaur.dat\noriginal-basilisk.dat\noriginal-minotaur.dat\noriginal-unicorn.dat\nunicorn.dat\n```\n:::\n:::\n\n\nThis loop runs the `cp` command once for each filename. The first time, when `$filename` expands to `basilisk.dat`, the shell executes:\n\n```{.bash filename=\"Bash\"}\ncp basilisk.dat original-basilisk.dat\n```\n\nand so on. Finally, let's clean up our copies\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nrm creatures/original-*\nls creatures/*\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncreatures/basilisk.dat\ncreatures/minotaur.dat\ncreatures/unicorn.dat\n```\n:::\n:::\n\n\n\n# Basics of bash scripting\n\nPull material from here \n\n- <https://swcarpentry.github.io/shell-novice/06-script/index.html>\n- <https://laderast.github.io/bash_for_bioinformatics/02-scripting-basics.html>\n\n# Basics of ssh\n\n- Explain what is ssh \n- Demo connecting to JHPCE via terminal.\n- Explain passwordless ssh with JHPCE (and GitHub)\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Add here.\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   Add here.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}