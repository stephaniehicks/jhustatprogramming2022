{
  "hash": "dc0386fc8d7c593984ab027bbf154601",
  "result": {
    "markdown": "---\ntitle: \"Relational databases and SQL basics\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to relational databases and SQL in R\"\ndate: 2022-12-08\ncategories: [module 3, week 7, databases, SQL, large data, tidyverse]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://dbi.r-dbi.org>\n2. <https://solutions.posit.co/connections/db/databases/sqlite/>\n3. <https://dbplyr.tidyverse.org>\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://www.stephaniehicks.com/jhuads2021/posts/2021-12-06-sql-basics>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Understand what are relational databases with SQL as an example\n- Learn about the `DBI`, `RSQLite`, `dbplyr` packages for interacting with SQL databses\n\n:::\n\n# Installation \n\n## Command-line tool `sqlite3`\n\nFor this lecture, we will use Unix shell, plus [SQLite3](https://www.sqlite.org/index.html) or [DB Browser for SQLite](https://sqlitebrowser.org).\n\nYou can see if the command-line tool `sqlite3` (also known as \"SQLite\") is already installed with \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsqlite3 --version\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n3.39.4 2022-09-07 20:51:41 6bf7a2712125fdc4d559618e3fa3b4944f5a0d8f8a4ae21165610e153f77aapl\n```\n:::\n:::\n\n\nIf not, you can install with `homebrew` or follow the instructions here: \n\n- <https://swcarpentry.github.io/sql-novice-survey/setup.html>\n\n## R packages\n\nYou will need to install these R packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"DBI\")\ninstall.packages(\"RSQLite\")\ninstall.packages(\"dbplyr\")\n```\n:::\n\n\nWe will load them here before kicking off the lecture. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(dbplyr)\n```\n:::\n\n\n\n\n# Relational databases\n\nData live anywhere and everywhere. Data \nmight be stored simply in a `.csv` or `.txt`\nfile. \n\nData might be stored in an Excel or \nGoogle Spreadsheet. Data might be stored in \nlarge databases that require users to write \nspecial functions to interact with to extract \nthe data they are interested in. \n\nA **relational database** is a digital database based on the [relational model of data](https://en.wikipedia.org/wiki/Relational_model), as proposed by E. F. Codd in 1970. \n\n![](https://upload.wikimedia.org/wikipedia/commons/8/8d/Relational_model_concepts.png)\n\n[**Source**: [Wikipedia](https://en.wikipedia.org/wiki/Relational_model)]\n\nA system used to maintain relational databases is a **relational database management system** (RDBMS). \n\nMany relational database systems have an option of using the **Structured Query Language** (SQL) (or SQLite -- very similar to SQL) for querying and maintaining the database.\n\n# SQL basics\n\n## Reading SQL data\n\nThere are several ways to \n[query databases in R](https://db.rstudio.com/getting-started/database-queries/). \n\nFirst, we will download a `.sqlite` database. This is a portable version of a `SQL` database. \n\nFor our purposes, we will use the \n\n- [chinook sqlite database](https://github.com/lerocha/chinook-database/blob/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite)\n\nThe database represents a \"digital media store, including tables for artists, \nalbums, media tracks, invoices and customers\".\n\nFrom the [Readme.md](https://github.com/lerocha/chinook-database) file: \n\n> Sample Data\n> \n> Media related data was created using real data from an iTunes Library. ... Customer and employee information was manually created using fictitious names, addresses that can be located on Google maps, and other well formatted data (phone, fax, email, etc.). Sales information is auto generated using random data for a four year period.\n\nHere we download the data to our `/data` folder: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022\n```\n:::\n\n```{.r .cell-code}\nif(!file.exists(here(\"data\", \"Chinook.sqlite\"))){\n  file_url <- paste0(\"https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite\")\n  download.file(file_url,\n                destfile=here(\"data\", \"Chinook.sqlite\"))\n}\n```\n:::\n\n\nWe can list the files and see the `.sqlite` database: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(here(\"data\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Chinook.sqlite\"            \"SRR1039508_subset_1.fastq\"\n[3] \"SRR1039509_subset_1.fastq\" \"SRR1039512_subset_1.fastq\"\n[5] \"SRR1039513_subset_1.fastq\"\n```\n:::\n:::\n\n\n## Connect to the SQL database\n\nThe main workhorse packages that we will use are the `DBI` and `dplyr` packages. \n\nLet's look at the `DBI::dbConnect()` help file\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?DBI::dbConnect\n```\n:::\n\n\nSo we need a driver and one example is `RSQLite::SQLite()`. \nLet's look at the help file\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?RSQLite::SQLite\n```\n:::\n\n\nOk, so with `RSQLite::SQLite()` and `DBI::dbConnect()` \nwe can connect to a `SQLite` database. \n\nLet's try that \nwith our `Chinook.sqlite` file that we downloaded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nconn <- DBI::dbConnect(drv = RSQLite::SQLite(), \n                       dbname = here(\"data\", \"Chinook.sqlite\"))\nconn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQLiteConnection>\n  Path: /Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite\n  Extensions: TRUE\n```\n:::\n:::\n\n\nSo we have opened up a connection with the SQLite database. \nNext, we can see what tables are available in the database \nusing the `dbListTables()` function: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(conn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Album\"         \"Artist\"        \"Customer\"      \"Employee\"     \n [5] \"Genre\"         \"Invoice\"       \"InvoiceLine\"   \"MediaType\"    \n [9] \"Playlist\"      \"PlaylistTrack\" \"Track\"        \n```\n:::\n:::\n\n\nFrom RStudio's website, there are several ways to interact with \nSQL Databases. One of the simplest ways that we will use here is \nto leverage the `dplyr` framework. \n\n> \"The `dplyr` package now has a generalized SQL backend for talking to databases, and the new `dbplyr` package translates R code into database-specific variants. As of this writing, SQL variants are supported for the following databases: Oracle, Microsoft SQL Server, PostgreSQL, Amazon Redshift, Apache Hive, and Apache Impala. More will follow over time.\n\nSo if we want to query a SQL databse with `dplyr`, the benefit of using `dbplyr` is: \n\n> \"You can write your code in `dplyr` syntax, and `dplyr` will translate your code into SQL. There are several benefits to writing queries in `dplyr` syntax: you can keep the same consistent language both for R objects and database tables, no knowledge of SQL or the specific SQL variant is required, and you can take advantage of the fact that `dplyr` uses lazy evaluation.\n\nLet's take a closer look at the `conn` database that we just connected to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dbplyr)\nsrc_dbi(conn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsrc:  sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\ntbls: Album, Artist, Customer, Employee, Genre, Invoice, InvoiceLine,\n  MediaType, Playlist, PlaylistTrack, Track\n```\n:::\n:::\n\n\nYou can think of the multiple tables similar to having \nmultiple worksheets in a spreadsheet. \n\nLet's try interacting with one. \n\n## Querying with `dplyr` syntax\n\nFirst, let's look at the first ten rows in the \n`Album` table using the `tbl()` function from `dplyr`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  head(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [10 x 3]\n# Database: sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\n   AlbumId Title                                 ArtistId\n     <int> <chr>                                    <int>\n 1       1 For Those About To Rock We Salute You        1\n 2       2 Balls to the Wall                            2\n 3       3 Restless and Wild                            2\n 4       4 Let There Be Rock                            1\n 5       5 Big Ones                                     3\n 6       6 Jagged Little Pill                           4\n 7       7 Facelift                                     5\n 8       8 Warner 25 Anos                               6\n 9       9 Plays Metallica By Four Cellos               7\n10      10 Audioslave                                   8\n```\n:::\n:::\n\n\nThe output looks just like a `data.frame` that we are familiar \nwith. But it's important to know that it's not really \na dataframe. For example, what about if we use \nthe `dim()` function? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA  3\n```\n:::\n:::\n\n\nInteresting! We see that the number of rows returned is `NA`. \nThis is because these functions are different than operating \non datasets in memory (e.g. loading data into memory using \n`read_csv()`). Instead, `dplyr` communicates differently \nwith a SQLite database. \n\nLet's consider our example. If we were to use straight SQL, \nthe following SQL query returns the first 10 rows \nfrom the `Album` table:\n\n``` sql\nSELECT *\nFROM `Album`\nLIMIT 10\n```\n\nIn the background, `dplyr` does the following: \n\n* translates your R code into SQL\n* submits it to the database\n* translates the database's response into an R data frame\n\nTo better understand the `dplyr` code, we can use the \n`show_query()` function: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nAlbum <- tbl(conn, \"Album\")\nshow_query(head(Album, n = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `Album`\nLIMIT 10\n```\n:::\n:::\n\n\nThis is nice because instead of having to write the \nSQL query our self, we can just use the `dplyr` and R \nsyntax that we are used to. \n\nHowever, the downside is that `dplyr` never gets to see the \nfull `Album` table. It only sends our query to the database, \nwaits for a response and returns the query. However, in this \nway we can interact with large datasets! \n\nMany of the usual `dplyr` functions are available too: \n\n* `select()`\n* `filter()`\n* `summarize()` \n\nand many join functions. \n\nOk let's try some of the functions out. \nFirst, let's count how many albums each \nartist has made. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  group_by(ArtistId) %>% \n  summarize(n = count(ArtistId)) %>% \n  head(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [10 x 2]\n# Database: sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\n   ArtistId     n\n      <int> <int>\n 1        1     2\n 2        2     2\n 3        3     1\n 4        4     1\n 5        5     1\n 6        6     2\n 7        7     1\n 8        8     3\n 9        9     1\n10       10     1\n```\n:::\n:::\n\n\n# data viz \n\nNext, let's plot it. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  group_by(ArtistId) %>% \n  summarize(n = count(ArtistId)) %>% \n  arrange(desc(n)) %>% \n  ggplot(aes(x = ArtistId, y = n)) + \n  geom_bar(stat = \"identity\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nLet's also extract the first letter from each \nalbum and plot the frequency of each letter. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  mutate(first_letter = str_sub(Title, end = 1)) %>% \n  ggplot(aes(first_letter)) + \n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Add here.\n:::\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://dbi.r-dbi.org>\n- <https://solutions.posit.co/connections/db/databases/sqlite/>\n- <https://dbplyr.tidyverse.org>\n\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}