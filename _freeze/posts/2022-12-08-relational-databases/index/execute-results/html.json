{
  "hash": "5bf43df0d3573184412bdb09cfa32c3b",
  "result": {
    "markdown": "---\ntitle: \"Relational databases and SQL basics\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to relational databases and SQL in R\"\ndate: 2022-12-08\ncategories: [module 3, week 7, databases, SQL, large data, tidyverse, DBI, RSQLite, dplyr, dbplyr]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://dbi.r-dbi.org>\n2. <https://solutions.posit.co/connections/db/databases/sqlite/>\n3. <https://dbplyr.tidyverse.org>\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://www.stephaniehicks.com/jhuads2021/posts/2021-12-06-sql-basics>\n- <https://swcarpentry.github.io/sql-novice-survey>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will be able to:**\n\n- Explain the difference between a table, a record, and a field in relational databases\n- Explain the difference between a database and a database manager\n- Write a query to select all values for specific fields from a single table\n- Write queries that display results in a particular order\n- Write queries that eliminate duplicate values from data\n- Write queries that select records that satisfy user-specified conditions\n- Learn about the `DBI`, `RSQLite`, `dbplyr` packages for making SQL queries in R\n\n:::\n\n# Installation \n\n## Command-line tool `sqlite3`\n\nFor this lecture, we will use Unix shell, plus [SQLite3](https://www.sqlite.org/index.html) or [DB Browser for SQLite](https://sqlitebrowser.org).\n\nYou can see if the command-line tool `sqlite3` (also known as \"SQLite\") is already installed with \n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsqlite3 --version\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n3.39.4 2022-09-07 20:51:41 6bf7a2712125fdc4d559618e3fa3b4944f5a0d8f8a4ae21165610e153f77aapl\n```\n:::\n:::\n\n\nIf not, you can install with `homebrew` or follow the instructions here: \n\n- <https://swcarpentry.github.io/sql-novice-survey/setup.html>\n\n## R packages\n\nYou will need to install these R packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"DBI\")\ninstall.packages(\"RSQLite\")\ninstall.packages(\"dbplyr\")\n```\n:::\n\n\nWe will load them here before kicking off the lecture. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(dbplyr)\n```\n:::\n\n\n\n# Relational databases\n\nData live anywhere and everywhere. Data \nmight be stored simply in a `.csv` or `.txt`\nfile. \n\nData might be stored in an Excel or \nGoogle Spreadsheet. Data might be stored in \nlarge databases that require users to write \nspecial functions to interact with to extract \nthe data they are interested in. \n\nA **relational database** is a digital database based on the [relational model of data](https://en.wikipedia.org/wiki/Relational_model), as proposed by E. F. Codd in 1970. \n\nBroadly relational databases are a way to store and manipulate information.\n\n- Databases are arranged as **tables** with a unique **relation variable** name \n- Each table has columns (also known as **fields** or **attributes**) that describe the data\n- Rows (also known as **records**) contain the data\n\n![](https://upload.wikimedia.org/wikipedia/commons/8/8d/Relational_model_concepts.png)\n\n[**Source**: [Wikipedia](https://en.wikipedia.org/wiki/Relational_model)]\n\n:::{.callout-tip}\n\n## Database managers\n\nWhen we are using a spreadsheet, we put formulas into cells to calculate new values based on old ones.\n\nWhen we are using a database, we send commands (usually called **queries**)\nto a **database manager** (a program that manipulates the database for us). \n\nThe database manager does whatever lookups and calculations the query specifies,\nreturning the results in a tabular form that we can then use as a starting point for further queries.\n\nExamples of database manager include: \n\n- Oracle\n- IBM DB2 \n- PostgreSQL\n- MySQL\n- Microsoft Access\n- SQLite (which is what we will use here)\n\nA system used to maintain relational databases is a **relational database management system** (RDBMS). \n\n:::\n\n## Languages\n\nWe write queries in a language called **Structured Query Language** (SQL), \nwhich provides hundreds of different ways to analyze and recombine data.\n\nMany database managers understand SQL but each stores data in a different way,\nso a database created with one cannot be used directly by another.\n\nHowever, every database manager can import and export data in a variety \nof formats like `.csv`, `.sql`, so it **is** possible to move \ninformation from one to another.\n\nNext, we will some example SQL queries that are common tasks for data scientists. \n\n# SQL basics\n\nIn this next few sections, we will use the SQLite database manager and interact \nwith it **interactively** on the command-line with the command `sqlite3`. \n\n:::{.callout-tip} \n\n### Getting Into and Out Of SQLite\n\nIn order to **use the SQLite commands interactively**, we need to\nenter into the SQLite console.  So, open up a terminal, and run\n\n```{.bash filename=\"Bash\"}\ncd data\nsqlite3 survey.db\n```\n\nThe SQLite command is `sqlite3` and you are telling SQLite to open up\nthe `survey.db`.  You need to specify the `.db` file, otherwise SQLite\nwill open up a temporary, empty database.\n\n- All SQLite-specific commands are prefixed with a `.` to distinguish them from SQL commands.\n- To get out of SQLite, type out `.exit` or `.quit`. For some terminals, `Ctrl-D` can also work.  \n- If you forget any SQLite `.` (dot) command, type `.help`.\n\n:::\n\n## Example data \n\nBefore we get into using SQLite to select the data, let's take a look at the tables of the database we will use in our examples:\n\n<div class=\"row\">\n  <div class=\"col-md-6\" markdown=\"1\">\n\n**Person**: People who took readings, `id` being the unique identifier for that person.\n\n|id      |personal |family\n|--------|---------|----------\n|dyer    |William  |Dyer\n|pb      |Frank    |Pabodie\n|lake    |Anderson |Lake\n|roe     |Valentina|Roerich\n|danforth|Frank    |Danforth\n\n**Site**: Locations of the `sites` where readings were taken.\n\n|name |lat   |long   |\n|-----|------|-------|\n|DR-1 |-49.85|-128.57|\n|DR-3 |-47.15|-126.72|\n|MSK-4|-48.87|-123.4 |\n\n**Visited**: Specific identification `id` of the precise locations where readings were taken at the sites and dates.\n\n|id   |site |dated     |\n|-----|-----|----------|\n|619  |DR-1 |1927-02-08|\n|622  |DR-1 |1927-02-10|\n|734  |DR-3 |1930-01-07|\n|735  |DR-3 |1930-01-12|\n|751  |DR-3 |1930-02-26|\n|752  |DR-3 |-null-    |\n|837  |MSK-4|1932-01-14|\n|844  |DR-1 |1932-03-22|\n\n  </div>\n  <div class=\"col-md-6\" markdown=\"1\">\n\n**Survey**: The measurements taken at each precise location on these sites. They are identified as `taken`. The field `quant` is short for quantity and indicates what is being measured.  The values are `rad`, `sal`, and `temp` referring to 'radiation', 'salinity' and 'temperature', respectively.\n\n|taken|person|quant|reading|\n|-----|------|-----|-------|\n|619  |dyer  |rad  |9.82   |\n|619  |dyer  |sal  |0.13   |\n|622  |dyer  |rad  |7.8    |\n|622  |dyer  |sal  |0.09   |\n|734  |pb    |rad  |8.41   |\n|734  |lake  |sal  |0.05   |\n|734  |pb    |temp |-21.5  |\n|735  |pb    |rad  |7.22   |\n|735  |-null-|sal  |0.06   |\n|735  |-null-|temp |-26.0  |\n|751  |pb    |rad  |4.35   |\n|751  |pb    |temp |-18.5  |\n|751  |lake  |sal  |0.1    |\n|752  |lake  |rad  |2.19   |\n|752  |lake  |sal  |0.09   |\n|752  |lake  |temp |-16.0  |\n|752  |roe   |sal  |41.6   |\n|837  |lake  |rad  |1.46   |\n|837  |lake  |sal  |0.21   |\n|837  |roe   |sal  |22.5   |\n|844  |roe   |rad  |11.25  |\n\n  </div>\n</div>\n\n## SQL `.tables` and `.schema`\n\nIn an interactive `sqlite3` session, \n\n- Type `.tables` to list the tables in the database\n- Type `.schema` to see the SQL statements used to create the tables in the database.  The statements will have a list of the columns and the data types each column stores.\n\n:::{.callout-tip}\n\n### More about `.schema`\n\nThe output from `.schema` is formatted as <**columnName** *dataType*>.  \n\n```{.sql filename=\"Output\"}\nCREATE TABLE Person (id text, personal text, family text);\nCREATE TABLE Site (name text, lat real, long real);\nCREATE TABLE Survey (taken integer, person text, quant text, reading real);\nCREATE TABLE Visited (id integer, site text, dated text);\n```\n\nThus we can see from the first line that the table **Person** has three columns:\n\n- **id** with type _text_\n- **personal** with type _text_\n- **family** with type _text_\n\n:::\n\nThe available data types vary based on the database manager - you can search online for what data types are supported.\n\n\n# SQL command `SELECT`\n\nFor now, let's write an SQL query that displays scientists' names.\n\nWe do this using the SQL command `SELECT`, giving it the names of the \ncolumns we want and the table we want them from. \n\nOur query looks like this:\n\n```{.sql filename=\"SQL\"}\nSELECT family, personal FROM Person;\n```\n\nAnd the output looks like this: \n\n```{.sql filename=\"Output\"}\n|family  |personal |\n|--------|---------|\n|Dyer    |William  |\n|Pabodie |Frank    |\n|Lake    |Anderson |\n|Roerich |Valentina|\n|Danforth|Frank    |\n```\n\n:::{.callout-tip}\n\n### Important \n\nThe **semicolon at the end of the query** tells the database manager that the query is complete and ready to run.\n\n:::\n\n\nWe have written our commands in upper case and the names for the table and columns\nin lower case, but we don't have to because SQL is **case insensitive**. \n\n```{.sql filename=\"SQL\"}\nSeLeCt FaMiLy, PeRsOnAl FrOm PeRsOn;\n```\n\nOutput: \n\n```{.sql filename=\"Output\"}\n|family  |personal |\n|--------|---------|\n|Dyer    |William  |\n|Pabodie |Frank    |\n|Lake    |Anderson |\n|Roerich |Valentina|\n|Danforth|Frank    |\n```\n\n:::{.callout-tip}\n\n### Pro-tip\n\nYou can use SQL's case insensitivity to distinguish between different parts of an SQL statement.\n\nHere, we use the convention of using \n\n- UPPER CASE for SQL keywords (such as `SELECT` and `FROM`)\n- Title Case for table names\n- lower case for field names\n\nWhatever casing convention you choose, please be consistent: complex queries are hard\nenough to read without the extra cognitive load of random\ncapitalization.\n\n:::\n\n\n\n:::{.callout-tip}\n\n### More about the `;`\n\nWhile we are on the topic of SQL's syntax, one aspect of SQL's syntax\nthat can frustrate novices and experts alike is forgetting to finish a\ncommand with `;` (semicolon).  \n\nWhen you press enter for a command\nwithout adding the `;` to the end, it can look something like this:\n\n```{.sql filename=\"Output\"}\nSELECT id FROM Person\n...>\n...>\n```\n\nThis is SQL's prompt, where it is waiting for additional commands or\nfor a `;` to let SQL know to finish.  \n\nThis is easy to fix!  Just type `;` and press enter!\n\n:::\n\n## More about `SELECT`\n\nRow and columns in a database table are not actually stored in any particular order.\n\nThey will **always be displayed** in some order, but we can control that in various ways.\n\n:::{.callout-note}\n\n### Example\n\nWe could swap the columns in the output by writing our query as:\n\n```{.sql filename=\"SQL\"}\nSELECT personal, family FROM Person;\n```\n\n```{.sql filename=\"Output\"}\n|personal |family  |\n|---------|--------|\n|William  |Dyer    |\n|Frank    |Pabodie |\n|Anderson |Lake    |\n|Valentina|Roerich |\n|Frank    |Danforth|\n```\n\nor even repeat columns:\n\n```{.sql filename=\"SQL\"}\nSELECT id, id, id FROM Person;\n```\n\n```{.sql filename=\"Output\"}\n|id      |id      |id      |\n|--------|--------|--------|\n|dyer    |dyer    |dyer    |\n|pb      |pb      |pb      |\n|lake    |lake    |lake    |\n|roe     |roe     |roe     |\n|danforth|danforth|danforth|\n```\n\n:::\n\n### The `*` operator\n\nAs a shortcut, we can select all of the columns in a table using `*`:\n\n```{.sql filename=\"SQL\"}\nSELECT * FROM Person;\n```\n\n```{.sql filename=\"Output\"}\n|id      |personal |family  |\n|--------|---------|--------|\n|dyer    |William  |Dyer    |\n|pb      |Frank    |Pabodie |\n|lake    |Anderson |Lake    |\n|roe     |Valentina|Roerich |\n|danforth|Frank    |Danforth|\n```\n\n\n## Sorting and removing duplicates\n\nIn this section, we will explore the following questions of the Antarctic data\n\n- What are the unique types of measurements taken in `Survey`?\n- Which scientists took measurements on the expedition?\n\nTo answer the first question, we will extract the values in column `quant` \n(short for quantity) from `Survey`, which contains \nvalues `rad`, `sal`, and `temp` referring to ‘radiation’, ‘salinity’ \nand ‘temperature’, respectively. \n\nHowever, we only want the unique value labels. \n\nThe following will extract the `quant` column from the `Survey` table, \nbut not return unique / distinct labels.\n\n```{.sql filename=\"SQL\"}\nSELECT quant FROM Survey;\n```\n\nBut, adding the `DISTINCT` keyword to our query eliminates the redundant output to\nmake the result more readable: \n\n```{.sql filename=\"SQL\"}\nSELECT DISTINCT quant FROM Survey;\n```\n\n\n```{.sql filename=\"Output\"}\n|quant|\n|-----|\n|rad  |\n|sal  |\n|temp |\n```\n\nYou can also use the `DISTINCT` keyword on multiple columns.\n\nIf we select more than one column, distinct **sets** of values are returned\n(in this case **pairs**, because we are selecting two columns) and \n**duplicates are removed**:\n\n\n```{.sql filename=\"SQL\"}\nSELECT DISTINCT taken, quant FROM Survey;\n```\n\n```{.sql filename=\"Output\"}\n|taken|quant|\n|-----|-----|\n|619  |rad  |\n|619  |sal  |\n|622  |rad  |\n|622  |sal  |\n|734  |rad  |\n|734  |sal  |\n|734  |temp |\n|735  |rad  |\n|735  |sal  |\n|735  |temp |\n|751  |rad  |\n|751  |temp |\n|751  |sal  |\n|752  |rad  |\n|752  |sal  |\n|752  |temp |\n|837  |rad  |\n|837  |sal  |\n|844  |rad  |\n```\n\nNext, we will look at the `Person` table and sort the scientists names. \n\nDatabase records are not necessarily sorted in any particular order. \n\nIf you want to have the table returned sorted in a particular way, you add the `ORDER BY` clause to our query:\n\n```{.sql filename=\"SQL\"}\nSELECT * FROM Person ORDER BY id;\n```\n\n\n```{.sql filename=\"Output\"}\n|id     |personal |family  |\n|-------|---------|--------|\n|danfort|Frank    |Danforth|\n|dyer   |William  |Dyer    |\n|lake   |Anderson |Lake    |\n|pb     |Frank    |Pabodie |\n|roe    |Valentina|Roerich |\n```\n\nThe default is to sort in an ascending order, but we can sort in a descending order using `DESC` (for \"descending\"):\n\n```{.sql filename=\"SQL\"}\nSELECT * FROM person ORDER BY id DESC;\n```\n\n\n```{.sql filename=\"Output\"}\n|id     |personal |family  |\n|-------|---------|--------|\n|roe    |Valentina|Roerich |\n|pb     |Frank    |Pabodie |\n|lake   |Anderson |Lake    |\n|dyer   |William  |Dyer    |\n|danfort|Frank    |Danforth|\n```\n\n(And if we want to make it clear that we're sorting in ascending order,\nwe can use `ASC` instead of `DESC`.)\n\n:::{.callout-tip}\n\n### Example\n\nLet's look at which scientist (`person`) measured what quantities (`quant`) during \neach visit (`taken`) with the `Survey` table. \n\nWe also want to sort by two columns at once\n\n- Sort results first in ascending order by `taken`\n- And then in descending order by `person` within each group of equal `taken` values:\n\n```{.sql filename=\"SQL\"}\nSELECT taken, person, quant FROM Survey ORDER BY taken ASC, person DESC;\n```\n\n\n```{.sql filename=\"Output\"}\n|taken|person|quant|\n|-----|------|-----|\n|619  |dyer  |rad  |\n|619  |dyer  |sal  |\n|622  |dyer  |rad  |\n|622  |dyer  |sal  |\n|734  |pb    |rad  |\n|734  |pb    |temp |\n|734  |lake  |sal  |\n|735  |pb    |rad  |\n|735  |-null-|sal  |\n|735  |-null-|temp |\n|751  |pb    |rad  |\n|751  |pb    |temp |\n|751  |lake  |sal  |\n|752  |roe   |sal  |\n|752  |lake  |rad  |\n|752  |lake  |sal  |\n|752  |lake  |temp |\n|837  |roe   |sal  |\n|837  |lake  |rad  |\n|837  |lake  |sal  |\n|844  |roe   |rad  |\n```\n\nThis query gives us a good idea of which scientist was involved in which visit,\nand what measurements they performed during the visit.\n\n:::\n\n\nLooking at the table, it seems like some scientists specialized in\ncertain kinds of measurements.  \n\nWe can examine which scientists performed which measurements by selecting \nthe appropriate columns and removing duplicates.\n\n```{.sql filename=\"SQL\"}\nSELECT DISTINCT quant, person FROM Survey ORDER BY quant ASC;\n```\n\n```{.sql filename=\"Output\"}\n|quant|person|\n|-----|------|\n|rad  |dyer  |\n|rad  |pb    |\n|rad  |lake  |\n|rad  |roe   |\n|sal  |dyer  |\n|sal  |lake  |\n|sal  |-null-|\n|sal  |roe   |\n|temp |pb    |\n|temp |-null-|\n|temp |lake  |\n```\n\n\n## Other important tasks\n\nThere are many other tasks you can do with SQL, but for purposes of the lecture, I will leave you to work through this carpentries tutorial if you want to know more: \n\n- <https://swcarpentry.github.io/sql-novice-survey>\n\n### Filtering \n\nHow can you select subsets of data? You use `WHERE`. \n\nHere is an example of filtering for all rows that contain \"dyer\" in the `Person` column. \n\n```{.sql filename=\"SQL\"}\nSELECT * FROM Survey WHERE person = \"dyer\";\n```\n\n```{.sql filename=\"Output\"}\n619|dyer|rad|9.82\n619|dyer|sal|0.13\n622|dyer|rad|7.8\n622|dyer|sal|0.09\n```\n\nFor more information about filtering, read through this tutorial: \n\n- <https://swcarpentry.github.io/sql-novice-survey/03-filter>\n\n### And more\n\nThe carpentries tutorial has so much  more including how to: \n\n- Calculating new values (<https://swcarpentry.github.io/sql-novice-survey/04-calc>)\n- How to deal with missing data (<https://swcarpentry.github.io/sql-novice-survey/05-null>)\n- How to aggregate data to calculate summaries (<https://swcarpentry.github.io/sql-novice-survey/06-agg>)\n- How to write queries that joins together two tables (<https://swcarpentry.github.io/sql-novice-survey/07-join>)\n- How to create tables or modify exisiting data in tables (<https://swcarpentry.github.io/sql-novice-survey/09-create>)\n\n\n# SQL in R\n\nThus far, everything we have done with SQL has been through an interactive session with `sqlite3`. \n\nYou can also access a database with R (and other programming languages too!). Library and functions may differ, but concepts are the same. \n\n## Connect to the SQL database\n\nThe main workhorse packages that we will use are the `DBI` and `RSQLite` packages. \n\n- [`DBI`](https://dbi.r-dbi.org/) is an R package that connects R to database management systems (DBMS). `DBI` separates the connectivity to the DBMS into a “front-end” and a “back-end”. The package defines an interface that is implemented by DBI backends such as RPostgres, RMariaDB, RSQLite, odbc, bigrquery, and more! \n- [`RSQLite`](https://rsqlite.r-dbi.org/) is an R package that embeds the SQLite database engine in R, providing a DBI-compliant interface. `SQLite` is a public-domain, single-user, very light-weight database engine that implements a decent subset of the SQL 92 standard, including the core table creation, updating, insertion, and selection operations, plus transaction management.\n\n## Example workflow \n\n:::{.callout-note}\n\n### Example\n\nHere's a short R program that sorts the scientists names in a descending order from\nfrom an SQLite database stored in a file called `survey.db`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RSQLite)\nconnection <- dbConnect(drv = RSQLite::SQLite(), \n                        dbname = here::here(\"posts\", \"2022-12-08-relational-databases\", \"data\", \"survey.db\"))\nresults <- dbGetQuery(connection, \"SELECT * FROM Person ORDER BY id DESC;\")\nprint(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        id  personal   family\n1      roe Valentina  Roerich\n2       pb     Frank  Pabodie\n3     lake  Anderson     Lake\n4     dyer   William     Dyer\n5 danforth     Frank Danforth\n```\n:::\n\n```{.r .cell-code}\ndbDisconnect(connection)\n```\n:::\n\n\n:::\n\nLet's break this down. \n\nThe program starts by **importing the `RSQLite` library**.\n\nIf we were connecting to MySQL, DB2, or some other database,\nwe would import a different library, but all of them provide the same functions,\nso that the rest of our program does not have to change\n(at least, not much) if we switch from one database to another.\n\nLine 2 **establishes a connection to the database**.\n\nSince we're using SQLite, all we need to specify is the name of the database file.\nOther systems may require us to provide a username and password as well.\n\nOn line 3, we **retrieve the results from an SQL query**.\n\nIt's our job to make sure that SQL is properly formatted;\nif it isn't, or if something goes wrong when it is being executed,\nthe database will report an error.\n\nThis result is a `data.frame` with one row for each entry and one column for each column in the database.\n\nFinally, the last line **closes our connection**, since the database can only \nkeep a limited number of these open at one time.\n\nSince establishing a connection takes time, though, we should not open a \nconnection, do one operation, then close the connection, only to reopen \nit a few microseconds later to do another operation.\n\nInstead, it's normal to create one connection that stays open for the lifetime of the program.\n\nQueries in real applications will often depend on values provided by users.\n\nFor example,\nthis function takes a user's ID as a parameter and returns only the rows with their ID:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RSQLite)\nconnection <- dbConnect(drv = SQLite(), \n                        dbname = here::here(\"posts\", \"2022-12-08-relational-databases\", \"data\", \"survey.db\"))\n\ngetName <- function(personID) {\n  query <- paste0(\"SELECT * FROM Survey WHERE person ='\", \n                  personID, \"';\")\n  return(dbGetQuery(connection, query))\n}\n\ngetName(\"dyer\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  taken person quant reading\n1   619   dyer   rad    9.82\n2   619   dyer   sal    0.13\n3   622   dyer   rad    7.80\n4   622   dyer   sal    0.09\n```\n:::\n\n```{.r .cell-code}\ndbDisconnect(connection)\n```\n:::\n\n\nWe use string concatenation on the first line of this function\nto construct a query containing the user ID we have been given.\n\n## Database helper functions in R\n\nR's database interface packages (like `RSQLite`) all share \na common set of helper functions useful for exploring databases and \nreading/writing entire tables at once.\n\nTo view all tables in a database, we can use `dbListTables()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconnection <- dbConnect(SQLite(), \n                        here::here(\"posts\", \"2022-12-08-relational-databases\", \"data\", \"survey.db\"))\ndbListTables(connection)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Person\"  \"Site\"    \"Survey\"  \"Visited\"\n```\n:::\n:::\n\n\n\n\nTo view all column names of a table, use `dbListFields()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListFields(connection, \"Survey\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"taken\"   \"person\"  \"quant\"   \"reading\"\n```\n:::\n:::\n\n\n\nTo read an entire table as a dataframe, use `dbReadTable()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbReadTable(connection, \"Person\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        id  personal   family\n1     dyer   William     Dyer\n2       pb     Frank  Pabodie\n3     lake  Anderson     Lake\n4      roe Valentina  Roerich\n5 danforth     Frank Danforth\n```\n:::\n:::\n\n\n\nFinally, to write an entire table to a database, you can use `dbWriteTable()`. \n\n:::{.callout-note}\n\nWe will always want to use the `row.names = FALSE` argument or R \nwill write the row names as a separate column. \n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(connection, \"iris\", iris, row.names = FALSE)\nhead(dbReadTable(connection, \"iris\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n:::\n\n\nIn this example we will write R's built-in `iris` dataset as a table in `survey.db`.\n\nWhich you can see here: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(connection)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Person\"  \"Site\"    \"Survey\"  \"Visited\" \"iris\"   \n```\n:::\n:::\n\n\nWe can remove `iris` as a table with `dbRemoveTable()` and check it's been removed with `dbListTables()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbRemoveTable(connection, \"iris\")\ndbListTables(connection)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Person\"  \"Site\"    \"Survey\"  \"Visited\"\n```\n:::\n:::\n\n\nAnd as always, remember to close the database connection when done!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(connection)\n```\n:::\n\n\n\n# SQL queries with `dplyr`\n\nIn this next section, we will switch datasets for variety sake. \n\n## Example: album covers \n\nWe will use the \n\n- [chinook sqlite database](https://github.com/lerocha/chinook-database/blob/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite)\n\nThe database represents a \"digital media store, including tables for artists, \nalbums, media tracks, invoices and customers\".\n\nFrom the [Readme.md](https://github.com/lerocha/chinook-database) file: \n\n> Sample Data\n> \n> Media related data was created using real data from an iTunes Library. ... Customer and employee information was manually created using fictitious names, addresses that can be located on Google maps, and other well formatted data (phone, fax, email, etc.). Sales information is auto generated using random data for a four year period.\n\nThe data are saved in our `/data` folder: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022\n```\n:::\n\n```{.r .cell-code}\nlist.files(here(\"data\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Chinook.sqlite\"            \"SRR1039508_subset_1.fastq\"\n[3] \"SRR1039509_subset_1.fastq\" \"SRR1039512_subset_1.fastq\"\n[5] \"SRR1039513_subset_1.fastq\"\n```\n:::\n:::\n\n\n## Connect to the SQLite database\n\nLet's connect to the `Chinook.sqlite` file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconnection <- dbConnect(SQLite(), \n                        here(\"data\", \"Chinook.sqlite\"))\n```\n:::\n\n\nSo we have opened up a connection with the SQLite database. \nNext, we can see what tables are available in the database \nusing the `dbListTables()` function: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(connection)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Album\"         \"Artist\"        \"Customer\"      \"Employee\"     \n [5] \"Genre\"         \"Invoice\"       \"InvoiceLine\"   \"MediaType\"    \n [9] \"Playlist\"      \"PlaylistTrack\" \"Track\"        \n```\n:::\n:::\n\n\nI have shown you how to write SQL queries with `dbGetQuery()`. \n\nAn alternative approach to interact with SQL databases is to leverage the `dplyr` framework. \n\n> \"The `dplyr` package now has a generalized SQL backend for talking to databases, and the new `dbplyr` package translates R code into database-specific variants. As of this writing, SQL variants are supported for the following databases: Oracle, Microsoft SQL Server, PostgreSQL, Amazon Redshift, Apache Hive, and Apache Impala. More will follow over time.\n\nSo if we want to query a SQL databse with `dplyr`, the benefit of using `dbplyr` is: \n\n> \"You can write your code in `dplyr` syntax, and `dplyr` will translate your code into SQL. There are several benefits to writing queries in `dplyr` syntax: you can keep the same consistent language both for R objects and database tables, no knowledge of SQL or the specific SQL variant is required, and you can take advantage of the fact that `dplyr` uses lazy evaluation.\n\nLet's take a closer look at the `conn` database that we just connected to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dbplyr)\nsrc_dbi(connection)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsrc:  sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\ntbls: Album, Artist, Customer, Employee, Genre, Invoice, InvoiceLine,\n  MediaType, Playlist, PlaylistTrack, Track\n```\n:::\n:::\n\n\nYou can think of the multiple tables similar to having \nmultiple worksheets in a spreadsheet. \n\nLet's try interacting with one. \n\n## Using `dplyr`\n\nFirst, let's look at the first ten rows in the \n`Album` table using the `tbl()` function from `dplyr`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(connection, \"Album\") %>%\n  head(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [10 x 3]\n# Database: sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\n   AlbumId Title                                 ArtistId\n     <int> <chr>                                    <int>\n 1       1 For Those About To Rock We Salute You        1\n 2       2 Balls to the Wall                            2\n 3       3 Restless and Wild                            2\n 4       4 Let There Be Rock                            1\n 5       5 Big Ones                                     3\n 6       6 Jagged Little Pill                           4\n 7       7 Facelift                                     5\n 8       8 Warner 25 Anos                               6\n 9       9 Plays Metallica By Four Cellos               7\n10      10 Audioslave                                   8\n```\n:::\n:::\n\n\nThe output looks just like a `data.frame` that we are familiar \nwith. But it's important to know that it's not really \na data frame. For example, what about if we use \nthe `dim()` function? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(connection, \"Album\") %>%\n  dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA  3\n```\n:::\n:::\n\n\nInteresting! We see that the number of rows returned is `NA`. \nThis is because these functions are different than operating \non datasets in memory (e.g. loading data into memory using \n`read_csv()`).\n\nInstead, `dplyr` communicates differently \nwith a SQLite database. \n\nLet's consider our example. If we were to use straight SQL, \nthe following SQL query returns the first 10 rows \nfrom the `Album` table:\n\n```{.sql filename=\"SQL\"}\nSELECT * FROM Album LIMIT 10;\n```\n\n```{.sql filename=\"Output\"}\n1|For Those About To Rock We Salute You|1\n2|Balls to the Wall|2\n3|Restless and Wild|2\n4|Let There Be Rock|1\n5|Big Ones|3\n6|Jagged Little Pill|4\n7|Facelift|5\n8|Warner 25 Anos|6\n9|Plays Metallica By Four Cellos|7\n10|Audioslave|8\n```\n\nIn the background, `dplyr` does the following: \n\n* translates your R code into SQL\n* submits it to the database\n* translates the database's response into an R data frame\n\nTo better understand the `dplyr` code, we can use the \n`show_query()` function: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nAlbum <- tbl(connection, \"Album\")\nshow_query(head(Album, n = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `Album`\nLIMIT 10\n```\n:::\n:::\n\n\nThis is nice because instead of having to write the \nSQL query our self, we can just use the `dplyr` and R \nsyntax that we are used to. \n\nHowever, the downside is that `dplyr` never gets to see the \nfull `Album` table. It **only sends our query to the database**, \nwaits for a response and returns the query. \n\nHowever, in this way we can interact with large datasets! \n\nMany of the usual `dplyr` functions are available too: \n\n* `select()`\n* `filter()`\n* `summarize()` \n\nand many join functions. \n\nOk let's try some of the functions out. \nFirst, let's count how many albums each \nartist has made. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(connection, \"Album\") %>%\n  group_by(ArtistId) %>% \n  summarize(n = count(ArtistId)) %>% \n  head(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [10 x 2]\n# Database: sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\n   ArtistId     n\n      <int> <int>\n 1        1     2\n 2        2     2\n 3        3     1\n 4        4     1\n 5        5     1\n 6        6     2\n 7        7     1\n 8        8     3\n 9        9     1\n10       10     1\n```\n:::\n:::\n\n\n## data viz \n\nNext, let's plot it. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(connection, \"Album\") %>%\n  group_by(ArtistId) %>% \n  summarize(n = count(ArtistId)) %>% \n  arrange(desc(n)) %>% \n  ggplot(aes(x = ArtistId, y = n)) + \n  geom_bar(stat = \"identity\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nLet's also extract the first letter from each \nalbum and plot the frequency of each letter. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(connection, \"Album\") %>%\n  mutate(first_letter = str_sub(Title, end = 1)) %>% \n  ggplot(aes(first_letter)) + \n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nIf you decide to make an album, you should try picking a less frequently used letter like E, J, K, Q, U, W, or Z! \n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\nUsing the `survey.db` database: \n\n1. Use `.schema` to identify column that contains integers\n2. Write a query that selects only the `name` column from the `Site` table.\n3. Many people format queries in the following two ways. What style do you find easiest to read, and why?\n\n```\nSELECT personal, family FROM person;\n```\n\nor\n\n```\nselect Personal, Family from PERSON;\n```\n\n4. Write a query that selects distinct dates from the `Visited` table.\n5. Write a query that displays the full names of the scientists in the `Person` table, ordered by family name.\n\n:::\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://dbi.r-dbi.org>\n- <https://solutions.posit.co/connections/db/databases/sqlite/>\n- <https://dbplyr.tidyverse.org>\n- <https://swcarpentry.github.io/sql-novice-survey>\n\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}