{
  "hash": "09e0002f4cb80deecfce39fdb7c3ccdb",
  "result": {
    "markdown": "---\ntitle: \"Relational databases and SQL basics\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to relational databases and SQL\"\ndate: 2022-12-08\ndraft: true\ncategories: [module 3, week 7, databases, SQL]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  Add here.\n2.  Add here.\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   Add here.\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Add here.\n:::\n\n# Add lecture here\n\nBefore we begin, you will need to install\nthese packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"DBI\")\ninstall.packages(\"RSQLite\")\ninstall.packages(\"dbplyr\")\n```\n:::\n\n\nNow we load a few R packages\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(dbplyr)\n```\n:::\n\n\n## Reading in from `SQLite` database\n\nAnother important type of data you might interact with \nare databases (such as `SQL` or `SQLite`). There are several ways to \n[query databases in R](https://db.rstudio.com/getting-started/database-queries/). \n\nFirst, we will download a `.sqlite` database. This is a\nportable version of a `SQL` database. For our \npurposes, we will use the \n[chinook sqlite database here](https://github.com/lerocha/chinook-database/blob/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite). The database represents a \n\"digital media store, including tables for artists, \nalbums, media tracks, invoices and customers\".\n\nFrom the [Readme.md](https://github.com/lerocha/chinook-database) file: \n\n> Sample Data\n> \n> Media related data was created using real data from an iTunes Library. It is possible for you to use your own iTunes Library to generate the SQL scripts, see instructions below. Customer and employee information was manually created using fictitious names, addresses that can be located on Google maps, and other well formatted data (phone, fax, email, etc.). Sales information is auto generated using random data for a four year period.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022\n```\n:::\n\n```{.r .cell-code}\nif(!file.exists(here(\"data\", \"Chinook.sqlite\"))){\n  file_url <- paste0(\"https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite\")\n  download.file(file_url,\n                destfile=here(\"data\", \"Chinook.sqlite\"))\n}\nlist.files(here(\"data\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Chinook.sqlite\"            \"SRR1039508_subset_1.fastq\"\n[3] \"SRR1039509_subset_1.fastq\" \"SRR1039512_subset_1.fastq\"\n[5] \"SRR1039513_subset_1.fastq\"\n```\n:::\n:::\n\n\nThe main workhorse packages that we will use are \nthe `DBI` and `dplyr` packages. Let's look at the \n`DBI::dbConnect()` help file\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?DBI::dbConnect\n```\n:::\n\n\nSo we need a driver and one example is `RSQLite::SQLite()`. \nLet's look at the help file\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?RSQLite::SQLite\n```\n:::\n\n\nOk so with `RSQLite::SQLite()` and `DBI::dbConnect()` \nwe can connect to a `SQLite` database. Let's try that \nwith our `Chinook.sqlite` file that we downloaded. Chinook.sqlite\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nconn <- DBI::dbConnect(RSQLite::SQLite(), \n                       here(\"data\", \"Chinook.sqlite\"))\nconn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQLiteConnection>\n  Path: /Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite\n  Extensions: TRUE\n```\n:::\n:::\n\n\nSo we have opened up a connection with the SQLite database. \nNext, we can see what tables are available in the database \nusing the `dbListTables()` function: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(conn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Album\"         \"Artist\"        \"Customer\"      \"Employee\"     \n [5] \"Genre\"         \"Invoice\"       \"InvoiceLine\"   \"MediaType\"    \n [9] \"Playlist\"      \"PlaylistTrack\" \"Track\"        \n```\n:::\n:::\n\n\nFrom RStudio's website, there are several ways to interact with \nSQL Databases. One of the simplest ways that we will use here is \nto leverage the `dplyr` framework. \n\n> \"The `dplyr` package now has a generalized SQL backend for talking to databases, and the new `dbplyr` package translates R code into database-specific variants. As of this writing, SQL variants are supported for the following databases: Oracle, Microsoft SQL Server, PostgreSQL, Amazon Redshift, Apache Hive, and Apache Impala. More will follow over time.\n\nSo if we want to query a SQL databse with `dplyr, the \nbenefit of using `dbplyr` is: \n\n> \"You can write your code in `dplyr` syntax, and `dplyr` will translate your code into SQL. There are several benefits to writing queries in `dplyr` syntax: you can keep the same consistent language both for R objects and database tables, no knowledge of SQL or the specific SQL variant is required, and you can take advantage of the fact that `dplyr` uses lazy evaluation.\n\nLet's take a closer look at the `conn` database\nthat we just connected to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dbplyr)\nsrc_dbi(conn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsrc:  sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\ntbls: Album, Artist, Customer, Employee, Genre, Invoice, InvoiceLine,\n  MediaType, Playlist, PlaylistTrack, Track\n```\n:::\n:::\n\n\nYou can think of the multiple tables similar to having \nmultiple worksheets in a spreadsheet. \n\nLet's try interacting with one. \n\n### Querying with `dplyr` syntax\n\nFirst, let's look at the first ten rows in the \n`Album` table. \n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  head(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [10 x 3]\n# Database: sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\n   AlbumId Title                                 ArtistId\n     <int> <chr>                                    <int>\n 1       1 For Those About To Rock We Salute You        1\n 2       2 Balls to the Wall                            2\n 3       3 Restless and Wild                            2\n 4       4 Let There Be Rock                            1\n 5       5 Big Ones                                     3\n 6       6 Jagged Little Pill                           4\n 7       7 Facelift                                     5\n 8       8 Warner 25 Anos                               6\n 9       9 Plays Metallica By Four Cellos               7\n10      10 Audioslave                                   8\n```\n:::\n:::\n\n\nThe output looks just like a `data.frame` that we are familiar \nwith. But it's important to know that it's not really \na dataframe. For example, what about if we use \nthe `dim()` function? \n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA  3\n```\n:::\n:::\n\n\nInteresting! We see that the number of rows returned is `NA`. \nThis is because these functions are different than operating \non datasets in memory (e.g. loading data into memory using \n`read_csv()`). Instead, `dplyr` communicates differently \nwith a SQLite database. \n\nLet's consider our example. If we were to use straight SQL, \nthe following SQL query returns the first 10 rows \nfrom the `Album` table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSELECT *\nFROM `Album`\nLIMIT 10\n```\n:::\n\n\nIn the background, `dplyr` does the following: \n\n* translates your R code into SQL\n* submits it to the database\n* translates the database's response into an R data frame\n\nTo better understand the `dplyr` code, we can use the \n`show_query()` function: \n\n::: {.cell}\n\n```{.r .cell-code}\nAlbum <- tbl(conn, \"Album\")\nshow_query(head(Album, n = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT *\nFROM `Album`\nLIMIT 10\n```\n:::\n:::\n\n\nThis is nice because instead of having to write the \nSQL query ourself, we can just use the `dplyr` and R \nsyntax that we are used to. \n\nHowever, the downside is that `dplyr` never gets to see the \nfull `Album` table. It only sends our query to the database, \nwaits for a response and returns the query. However, in this \nway we can interact with large datasets! \n\nMany of the usual `dplyr` functions are available too: \n\n* `select()`\n* `filter()`\n* `summarize()` \n\nand many join functions. \n\nOk let's try some of the functions out. \nFirst, let's count how many albums each \nartist has made. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  group_by(ArtistId) %>% \n  summarize(n = count(ArtistId)) %>% \n  head(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [10 x 2]\n# Database: sqlite 3.39.4 [/Users/stephaniehicks/Documents/github/teaching/jhustatprogramming2022/data/Chinook.sqlite]\n   ArtistId     n\n      <int> <int>\n 1        1     2\n 2        2     2\n 3        3     1\n 4        4     1\n 5        5     1\n 6        6     2\n 7        7     1\n 8        8     3\n 9        9     1\n10       10     1\n```\n:::\n:::\n\n\nNext, let's plot it. \n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  group_by(ArtistId) %>% \n  summarize(n = count(ArtistId)) %>% \n  arrange(desc(n)) %>% \n  ggplot(aes(x = ArtistId, y = n)) + \n  geom_bar(stat = \"identity\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nLet's also extract the first letter from each \nalbum and plot the frequency of each letter. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"Album\") %>%\n  mutate(first_letter = str_sub(Title, end = 1)) %>% \n  ggplot(aes(first_letter)) + \n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Add here.\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   Add here.\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}