---
title: "Advanced command-line tools"
author: 
  - name: Stephanie Hicks
    url: https://stephaniehicks.com
    affiliation: Department of Biostatistics, Johns Hopkins
    affiliation_url: https://publichealth.jhu.edu
description: "Doing more powerful things on the command-line"
date: 2022-11-03
categories: [module 1, week 2, command-line]
---

```{r}
#| echo: false
#| message: false
#| warning: false
library(tidyverse)
```


# Pre-lecture materials

### Read ahead

::: callout-note
## Read ahead

**Before class, you can prepare by reading the following materials:**

1. <https://swcarpentry.github.io/shell-novice>
2. 
3. 

:::

### Acknowledgements

Material for this lecture was borrowed and adopted from

- <https://swcarpentry.github.io/shell-novice/04-pipefilter>
- <https://swcarpentry.github.io/shell-novice/05-loop>
- <https://swcarpentry.github.io/shell-novice/06-script>


# Learning objectives

::: callout-note
# Learning objectives

**At the end of this lesson you will:**

- Redirect a command’s output to a file with redirect operators (`>`, `>>`).
- Construct command pipelines with two or more stages with the pipe operator (`|`).
- Write a loop that applies one or more commands separately to each file in a set of files.
- Explain why spaces should not be used in file names inside of loops.

:::

# Pipes

## Capturing output from commands

In this section, we will continue to explore how to use pipes to **re-direct output** from to the terminal and write it to a file. 

:::{.callout-tip}

### Dataset 

The dataset we will use is a folder that contains six files describing some simple organic molecules. The `.pdb` extension indicates that these files are in Protein Data Bank format, a simple text format that specifies the type and position of each atom in the molecule.

```{bash}
ls proteins
```

:::

Let's count the lines in one of the files `cubane.pdb` using the `wc` command (**w**ord **c**ount): 

```{bash}
wc -l proteins/cubane.pdb
```



:::{.callout-note}

### Question

Using wildcard (`*`), list out all the number of lines in each `.pdb` file in the `protein` directory

```{bash}
## try it out 

```

:::

This is useful information, but all of that output gets printed to the screen and then it's gone. Let's try saving the output to a file with the redirection `>` operator: 

:::{.callout-tip}

### Redirection operator

In the previous lecture, we learned that if we wanted to redirect that output from printing to the terminal and write to a file, we use the `>` operator like so (`command > [file] `) where on the left side is output gets piped into a file on the right side. 

:::

:::{.callout-note}

### Question 

Write the commands for the followings tasks: 

1. Using the `>` redirect operator, pipe the output from our example above to a file called `lengths.txt`. 
2. Print the file contents in `length.txt` to the screen.

```{bash}
## try it out 

```

:::

## Appending data to a file 

In general, it is a **very bad idea** to try redirecting the output of a command that **operates on a file to the same file**. 

For example:

```{.bash filename="Bash"}
sort -n lengths.txt > lengths.txt
```

Doing something like this may give you incorrect results and/or delete the contents of `lengths.txt`.

An alternative is another type of redirect operator (`>>`), which is used to **append to a file** (`command >> [file]`). 

Let's try this out. 

:::{.callout-tip}

### Example

Now test the commands below to reveal the difference between the two operators

```{bash}
echo hello > testfile01.txt
```

```{bash}
echo hello >> testfile02.txt
```

**Task**: Try executing each command twice in a row and then examining the output files. What happened? 

:::

OK let's clean up our space before we move on

```{bash}
rm testfile01.txt testfile02.txt
```

## Passing output to another command

Another operator is the vertical bar (`|`) (or **pipe operator**) which is used between two commands to pass the output from one command as input to another command (`[first] | [second]`).

:::{.callout-tip}

### Example

Let's sort the rows in `lengths.txt` in a numeric order and then **pipe* the output into another command to show only the first row. 

```{bash}
cat lengths.txt
```


```{bash}
sort -n lengths.txt | head -n 1
```

:::

:::{.callout-note}

### Question 

Let's practice using the pipe operator and combine three commands together. Write the following commands and pipe the output with the `|` operator. 

Using the `*.pdb` files in the `protein` folder: 

1. Count the number of lines in each each `*.pdb` file. 
2. Sort the lines numerically in an ascending order. 
3. Show the first line of the output. 

```{bash}
## try it out

```


:::


# Loops	

**Loops** are a programming construct which allow us to **repeat a command** or set of commands **for each item in a list**.

- As such they are **key to productivity improvements through automation**. 
- Similar to wildcards and tab completion, **using loops also reduces the amount of typing required** (and hence reduces the number of typing mistakes).

Suppose we have several hundred genome data files ending in `.dat` and our goal is to extract a piece of information from each file. 

:::{.callout-tip}

### Dataset 

The dataset we will use is a folder that only has 3 example files (`basilisk.dat`, `minotaur.dat`, and `unicorn.dat`), but the principles can be applied to many many more files at once.

The structure of these files is the same. On the first three lines: 

- the common name, 
- classification, and 
- updated date 

The DNA sequences are given in the following lines within each file. Let’s look at the files:

```{bash}
cd creatures
head -n 5 basilisk.dat minotaur.dat unicorn.dat
```

:::

Here, we would like to **print out the classification for each species** (given on the second line of each file). 

One way to do this is for each file, we could use the command `head -n 2` and pipe this to `tail -n 1`. 

## Loop basics

Another way to do this is to use a loop to solve this problem, but first let’s look at the general form of a `for` loop, using the pseudo-code below:

```{.bash filename="Bash"}
for thing in list_of_things
do
    operation_using $thing    # Indentation within the loop is not required, but aids legibility
done
```

and we can apply this to our example like this:

```{bash}
cd creatures
for filename in basilisk.dat minotaur.dat unicorn.dat
do
    head -n 2 $filename | tail -n 1
done
```

:::{.callout-tip}

### Pro-tip

1. When using variables it is also possible to put the names into curly braces to clearly delimit the variable name: `$filename` is equivalent to `${filename}`, but is different from `${file}name`. You may find this notation in other people’s programs.

2. We have called the variable in this loop `filename` in order to make its purpose clearer to human readers. The shell itself doesn’t care what the variable is called; if we wrote this loop with `x`:

```{bash}
cd creatures
for x in basilisk.dat minotaur.dat unicorn.dat
do
    head -n 2 $x | tail -n 1
done
```

3. Spaces are used to separate the elements of the list that we are going to loop over. If one of those elements contains a space character, we need to surround it with quotes, and do the same thing to our loop variable.

```{bash}
for x in "spooky ghost" "scary monster" "creepy spider"
do
   echo $x
done
```

4. There are other types of loops including 

- The `for` loop: executes the given commands over a series of defined number of iterations
- The `while` loop: executes the given commands until the given condition changes from true to false
- The `until` loop: executes the given commands until a given condition becomes true
- The `select` loop: easy way to create a numbered menu from which users can select options. It is useful when you need to ask the user to choose one or more items from a list of choices.

:::


:::{.callout-note}

### Question 

Using the six files in the `proteins` folder, let's predict what the output of these loops are. 

```{.bash}
cd proteins
for datafile in *.pdb
do
    ls *.pdb
done
```


```{.bash}
cd proteins
for datafile in *.pdb
do
    ls $datafile
done
```


```{.bash}
cd proteins
for datafile in c*
do
    ls $datafile
done
```

```{.bash}
cd proteins
for datafile in *c*
do
    ls $datafile
done
```

:::



## Naming files

You can also use the variables in `for` loops to name files or folders. 

For example, let's say we want to save a version of the original files in the `creatures` folder, naming the copies `original-basilisk.dat` and `original-unicorn.dat`, etc. 

```{bash}
cd creatures
for filename in *.dat
do
    cp $filename original-$filename
done

ls *.dat
```

This loop runs the `cp` command once for each filename. The first time, when `$filename` expands to `basilisk.dat`, the shell executes:

```{.bash filename="Bash"}
cp basilisk.dat original-basilisk.dat
```

and so on. Finally, let's clean up our copies

```{bash}
rm creatures/original-*
ls creatures/*
```


# Basics of bash scripting

Pull material from here 

- <https://swcarpentry.github.io/shell-novice/06-script/index.html>
- <https://laderast.github.io/bash_for_bioinformatics/02-scripting-basics.html>

# Basics of ssh

- Explain what is ssh 
- Demo connecting to JHPCE via terminal.
- Explain passwordless ssh with JHPCE (and GitHub)



# Post-lecture materials

### Final Questions

Here are some post-lecture questions to help you think about the material discussed.

::: callout-note
### Questions

1.  Add here.
:::

### Additional Resources

::: callout-tip
-   Add here.
:::
