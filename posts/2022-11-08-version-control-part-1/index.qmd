---
title: "Version control (Part 1)"
author: 
  - name: Lukas Weber
    url: https://lmweber.org/
    affiliation: Department of Biostatistics, Johns Hopkins Bloomberg School of Public Health
    affiliation_url: https://publichealth.jhu.edu
description: "Introduction to version control with git and GitHub (part 1)"
date: 2022-11-08
categories: [module 1, week 3, version control, git, GitHub]
---


# Pre-lecture materials

### Read ahead


::: callout-note
## Read ahead

**Before class, you can prepare by reading the following materials:**

-   [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/)
:::


### Acknowledgements

Material for this lecture was borrowed and adopted from

-   [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/)


# Learning objectives


::: callout-note
# Learning objectives

**At the end of this lesson you will:**

-   Understand the benefits of an automated version control system.
-   Understand the basics of how automated version control systems work.
-   Configure git the first time it is used on a computer.
-   Create a local git repository.
-   Describe the purpose of the `.git` directory.
-   Understand the modify-add-commit cycle for files.
-   Distinguish between descriptive and non-descriptive commit messages.
:::


# Introduction

::: callout-note
### Questions

-   What is version control and why should I use it?
:::


We'll start by exploring how version control can be used to keep track of what one person did and when.

For a nice illustration, we will refer to the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/01-basics/index.html) lesson materials.


### Overview

We've all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word's Track Changes or Google Docs' version history.

Version control systems start with a base version of the document and then record changes you make each step of the way.

For example, two users can make independent sets of changes on the same document.

Unless multiple users make changes to the same section of the document - a conflict - you can incorporate two sets of changes into the same base document.

A version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files.

It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people.


::: callout-note
### Terminology

1.  `commit`: a record of each set of changes in a document or file
2.  `repository`: the complete history of commits for a particular project and their metadata
:::


::: callout-note
### Key Points

1.  Version control is like an unlimited 'undo'.
2.  Version control also allows many people to work in parallel.
:::


# Setting Up Git

::: callout-note
### Questions

-   How do I get set up to use Git?
:::


When we use Git on a new computer for the first time, we need to configure a few things:

-   our name and email address
-   what our preferred text editor is
-   and that we want to use these settings globally (i.e. for every project).

On a command line, Git commands are written as `git verb options`, where `verb` is what we actually want to do and `options` is additional optional information.

Here is how to set up Git on a new laptop:

```bash
$ git config --global user.name "My Name"
$ git config --global user.email "myemail@email.com"
```

This user name and email will be associated with your subsequent Git activity after this lesson.

For this lesson, we will be interacting with GitHub and so the email address used should be the same as the one used when setting up your GitHub account.


### Check settings

You can check your settings at any time:

```bash
$ git config --list
```


::: callout-note
### Git Help and Manual

If you forget the options of a `git` command, you can type `git <command> -h` or access the corresponding Git manual by typing `git <command> --help`, e.g.:

```bash
$ git config -h
$ git config --help
```

You can press Q to exit the manual.

You can also get the list of available git commands and further resources of the Git manual typing:

```bash
$ git help
```
:::


Note that we will omit the `$` from shell commands shown from here onwards to make it easier to run them interactively in this tutorial.


# Creating a Repository

::: callout-note
### Questions

-   Where does Git store information?
:::


Once Git is configured, we can start using it.

First, let's create a new directory in the Desktop folder for our work and then change the current working directory to the newly created one:

```bash
cd ~/Desktop
mkdir planets
cd planets
pwd
```

Then we tell Git to make `planets` a repository – a place where Git can store versions of our files:

```bash
git init
```

Note that the creation of the `planets` directory and its initialization as a repository are completely separate processes.

If we use `ls` to show the directory's contents, it appears that nothing has changed:

```bash
ls
```

But if we add the `-a` flag to show everything, we can see that Git has created a hidden directory within planets called `.git`:

```bash
ls -a
```

Git uses this special subdirectory to store all the information about the project, including the tracked files and sub-directories located within the project's directory.

If we ever delete the `.git` subdirectory, we will lose the project's history.

Next, we will change the default branch to be called `main.` This might be the default branch depending on your settings and version of git.

```bash
git checkout -b main
```

We can check that everything is set up correctly by asking Git to tell us the status of our project:

```bash
git status
```


::: callout-note
### Correcting `git init` Mistakes

Suppose you have created the Git repository in the wrong directory, or made some other mistake.

You can delete the git repository by simply deleting the `.git` directory, either in Finder / Windows Explorer or from the command line:

```bash
rm -rf .git
```

But be careful! Running this command in the wrong directory will remove the entire Git history of a project you might want to keep. Therefore, always check your current directory using the command `pwd`.
:::


::: callout-note
### Key Points

-   `git init` initializes a repository.
-   Git stores all of its repository data in the `.git` directory.
:::


# Tracking Changes

::: callout-note
### Questions

-   How do I record changes in Git?
-   How do I check the status of my version control repository?
-   How do I record notes about what changes I made and why?
:::


First let's make sure we're still in the right directory. You should be in the `planets` directory.

```bash
cd ~/Desktop/planets
```


### Adding a new file

Let's create a file called `mars.txt` that contains some notes about the Red Planet's suitability as a base.

We will use `touch` to create the file, and then open it in TextEdit or Notepad. Alternatively, you can use a command-line text editor such as `nano`.

```bash
touch mars.txt
```

Navigate to the directory in Finder / Windows Explorer and open the `.txt` file in TextEdit / Notepad.

Type the text below into the `mars.txt` file:

```
Cold and dry, but everything is my favorite color
```

Let's first verify that the file was properly created by running the list command (`ls`):

```bash
ls
```

`mars.txt` contains a single line, which we can see by running:

```bash
cat mars.txt
```

If we check the status of our project again, Git tells us that it's noticed the new file:

```bash
git status
```

The "untracked files" message means that there's a file in the directory that Git isn't keeping track of. We can tell Git to track a file using `git add`:

```bash
git add mars.txt
```

and then check that the right thing happened:

```bash
git status
```

Git now knows that it's supposed to keep track of `mars.txt`, but it hasn't recorded these changes as a commit yet. To get it to do that, we need to run one more command:

```bash
git commit -m "Start notes on Mars as a base"
```

When we run git commit, Git takes everything we have told it to save by using `git add` and stores a copy permanently inside the special `.git` directory. This permanent copy is called a commit (or revision) and its short identifier is f22b25e. Your commit may have another identifier.

We use the `-m` flag (for "message") to record a short, descriptive, and specific comment that will help us remember later on what we did and why. If we just run `git commit` without the `-m` option, Git will launch `nano` (or whatever other editor is configured as `core.editor`) so that we can write a longer message.

Good commit messages start with a brief (<50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence "If applied, this commit will". If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be.

If we run `git status` now:

```bash
git status
```

it tells us everything is up to date. If we want to know what we've done recently, we can ask Git to show us the project's history using `git log`:

```bash
git log
```

git log lists all commits made to a repository in reverse chronological order.


### Adding changes to a file

Now suppose we add more information to the file. (Again, we’ll edit with TextEdit / Notepad and then `cat` the file to show its contents.)

Paste the following text into the file:

```
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
```

When we run `git status` now, it tells us that a file it already knows about has been modified:

```bash
git status
```

The last line is the key phrase: "no changes added to commit". We have changed this file, but we haven't told Git we will want to save those changes (which we do with `git add`) nor have we saved them (which we do with `git commit`).

So let's do that now. It is good practice to always review our changes before saving them. We do this using `git diff`. This shows us the differences between the current state of the file and the most recently saved version:

```bash
git diff
```

The output is cryptic because it is actually a series of commands for tools like editors and `patch` telling them how to reconstruct one file given the other.

After reviewing our change, it's time to commit it:

```bash
git commit -m "Add concerns about effects of Mars' moons on Wolfman"
```

Whoops: Git won't commit because we didn't use `git add` first. Let's fix that:

```bash
git add mars.txt
git commit -m "Add concerns about effects of Mars' moons on Wolfman"
```


### Staging area

Git insists that we add files to the set we want to commit before actually committing anything. This allows us to commit our changes in stages and capture changes in logical portions rather than only large batches.

To allow for this, Git has a special staging area where it keeps track of things that have been added but not yet committed.


::: callout-note
### Staging Area

If you think of Git as taking snapshots of changes over the life of a project, `git add` specifies what will go in a snapshot (putting things in the staging area), and `git commit` then actually takes the snapshot, and makes a permanent record of it (as a commit).

If you don't have anything staged when you type git commit, Git will prompt you to use `git commit -a` or `git commit --all`, which will add all files. However, it's almost always better to explicitly add things to the staging area, because you might commit changes you forgot you made.

Try to stage things manually, or you might find yourself searching for "git undo commit" more than you would like!
:::


Let's watch as our changes to a file move from our editor to the staging area and into long-term storage. First, we'll add another line to the file:

```bash
cat mars.txt
```

```
Cold and dry, but everything is my favorite color
The two moons may be a problem for Wolfman
But the Mummy will appreciate the lack of humidity
```

```bash
git diff
```

So far, so good: we've added one line to the end of the file (shown with a `+` in the first column). Now let's put that change in the staging area and see what `git diff` reports:

```bash
git add mars.txt
git diff
```

There is no output: as far as Git can tell, there's no difference between what it's been asked to save permanently and what's currently in the directory. However, if we do this:

```bash
git diff --staged
```

it shows us the difference between the last committed change and what's in the staging area. Let's save our changes:

```bash
git commit -m "Discuss concerns about Mars' climate for Mummy"
```

check our status:

```bash
git status
```

and look at the history of what we've done so far:

```bash
git log
```


::: callout-note
### Word-based diffing

Sometimes, e.g. in the case of the text documents a line-wise diff is too coarse. That is where the `--color-words` option of `git diff` comes in very useful as it highlights the changed words using colors.
:::


::: callout-note
### Paging the Log

If the output of `git log` is too long to fit in your screen, Git splits it into pages.

To get out of the pager, press `Q`.

To move to the next page, press `Spacebar`.
:::


### Directories

Two important facts you should know about directories in Git.

First, Git does not track directories on their own, only files within them. Try it for yourself:

```bash
mkdir spaceships
git status
git add spaceships
git status
```

Note, our newly created empty directory `spaceships` does not appear in the list of untracked files even if we explicitly add it (via `git add`) to our repository.


Second, if you create a directory in your Git repository and populate it with files, you can add all files in the directory at once by:

```bash
git add <directory-with-files>
```

Try it for yourself:

```bash
touch spaceships/apollo-11 spaceships/sputnik-1
git status
git add spaceships
git status
```

Before moving on, we will commit these changes.

```bash
git commit -m "Add some initial thoughts on spaceships"
```

To recap, when we want to add changes to our repository, we first need to add the changed files to the staging area (`git add`) and then commit the staged changes to the repository (`git commit`).

For a visualization of this workflow, see the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/04-changes/index.html#directories) page.


### Exercises

::: callout-tip
### Choosing a Commit Message

Which of the following commit messages would be most appropriate for the last commit made to `mars.txt`?

1. "Changes"
2. "Added line 'But the Mummy will appreciate the lack of humidity' to mars.txt"
3. "Discuss effects of Mars' climate on the Mummy"
:::


::: callout-tip
### Committing Changes to Git

Which command(s) below would save the changes of `myfile.txt` to my local Git repository?

```bash
git commit -m "my recent changes"
```

```bash
git init myfile.txt
git commit -m "my recent changes"
```

```bash
git add myfile.txt
git commit -m "my recent changes"
```

```bash
git commit -m myfile.txt "my recent changes"
```
:::


Additional exercises are available on the [Software Carpentry: Version Control with Git](https://swcarpentry.github.io/git-novice/04-changes/index.html#choosing-a-commit-message) page.


::: callout-tip
### Key Points

-   `git status` shows the status of a repository.

-   Files can be stored in a project's working directory (which users see), the staging area (where the next commit is being built up) and the local repository (where commits are permanently recorded).

-   `git add` puts files in the staging area.

-   `git commit` saves the staged content as a new commit in the local repository.

-   Write a commit message that accurately describes your changes.
:::


# Post-lecture materials

### Final Questions

Here are some post-lecture questions to help you think about the material discussed.

::: callout-note
### Questions

1.  Add here.
:::

### Additional Resources

::: callout-tip
-   Add here.
:::

