---
title: "Relational databases and SQL basics"
author: 
  - name: Stephanie Hicks
    url: https://stephaniehicks.com
    affiliation: Department of Biostatistics, Johns Hopkins
    affiliation_url: https://publichealth.jhu.edu
description: "Introduction to relational databases and SQL in R"
date: 2022-12-08
categories: [module 3, week 7, databases, SQL, large data, tidyverse]
---

<!-- Add interesting quote -->

# Pre-lecture materials

### Read ahead

::: callout-note
## Read ahead

**Before class, you can prepare by reading the following materials:**

1. <https://dbi.r-dbi.org>
2. <https://solutions.posit.co/connections/db/databases/sqlite/>
3. <https://dbplyr.tidyverse.org>

:::

### Acknowledgements

Material for this lecture was borrowed and adopted from

- <https://www.stephaniehicks.com/jhuads2021/posts/2021-12-06-sql-basics>


# Learning objectives

::: callout-note
# Learning objectives

**At the end of this lesson you will be able to:**

- Explain the difference between a table, a record, and a field in relational databases
- Explain the difference between a database and a database manager
- Write a query to select all values for specific fields from a single table
- 
- Learn about the `DBI`, `RSQLite`, `dbplyr` packages for making SQL queries in R

:::

# Installation 

## Command-line tool `sqlite3`

For this lecture, we will use Unix shell, plus [SQLite3](https://www.sqlite.org/index.html) or [DB Browser for SQLite](https://sqlitebrowser.org).

You can see if the command-line tool `sqlite3` (also known as "SQLite") is already installed with 

```{bash}
sqlite3 --version
```

If not, you can install with `homebrew` or follow the instructions here: 

- <https://swcarpentry.github.io/sql-novice-survey/setup.html>

## R packages

You will need to install these R packages:

```{r}
#| eval: false
install.packages("DBI")
install.packages("RSQLite")
install.packages("dbplyr")
```

We will load them here before kicking off the lecture. 

```{r}
#| warning: false
#| message: false
library(tidyverse)
library(DBI)
library(RSQLite)
library(dbplyr)
```


# Relational databases

Data live anywhere and everywhere. Data 
might be stored simply in a `.csv` or `.txt`
file. 

Data might be stored in an Excel or 
Google Spreadsheet. Data might be stored in 
large databases that require users to write 
special functions to interact with to extract 
the data they are interested in. 

A **relational database** is a digital database based on the [relational model of data](https://en.wikipedia.org/wiki/Relational_model), as proposed by E. F. Codd in 1970. 

Broadly relational databases are a way to store and manipulate information.

- Databases are arranged as **tables** with a unique **relation variable** name 
- Each table has columns (also known as **fields** or **attributes**) that describe the data
- Rows (also known as **records**) contain the data

![](https://upload.wikimedia.org/wikipedia/commons/8/8d/Relational_model_concepts.png)

[**Source**: [Wikipedia](https://en.wikipedia.org/wiki/Relational_model)]

:::{.callout-tip}

## Database managers

When we are using a spreadsheet, we put formulas into cells to calculate new values based on old ones.

When we are using a database, we send commands (usually called **queries**)
to a **database manager** (a program that manipulates the database for us). 

The database manager does whatever lookups and calculations the query specifies,
returning the results in a tabular form that we can then use as a starting point for further queries.

Examples of database manager include: 

- Oracle
- IBM DB2 
- PostgreSQL
- MySQL
- Microsoft Access
- SQLite (which is what we will use here)

A system used to maintain relational databases is a **relational database management system** (RDBMS). 

:::

## Languages

We write queries in a language called **Structured Query Language** (SQL), 
which provides hundreds of different ways to analyze and recombine data.

Many database managers understand SQL but each stores data in a different way,
so a database created with one cannot be used directly by another.

However, every database manager can import and export data in a variety 
of formats like `.csv`, `.sql`, so it **is** possible to move 
information from one to another.

Next, we will some example SQL queries that are common tasks for data scientists. 

# SQL basics

In this next few sections, we will use the SQLite database manager and interact 
with it **interactively** on the command-line with the command `sqlite3`. 

:::{.callout-tip} 

### Getting Into and Out Of SQLite

In order to **use the SQLite commands interactively**, we need to
enter into the SQLite console.  So, open up a terminal, and run

```{.bash filename="Bash"}
cd data
sqlite3 survey.db
```

The SQLite command is `sqlite3` and you are telling SQLite to open up
the `survey.db`.  You need to specify the `.db` file, otherwise SQLite
will open up a temporary, empty database.

- All SQLite-specific commands are prefixed with a `.` to distinguish them from SQL commands.
- To get out of SQLite, type out `.exit` or `.quit`. For some terminals, `Ctrl-D` can also work.  
- If you forget any SQLite `.` (dot) command, type `.help`.

:::

## Example data 

Before we get into using SQLite to select the data, let's take a look at the tables of the database we will use in our examples:

<div class="row">
  <div class="col-md-6" markdown="1">

**Person**: People who took readings, `id` being the unique identifier for that person.

|id      |personal |family
|--------|---------|----------
|dyer    |William  |Dyer
|pb      |Frank    |Pabodie
|lake    |Anderson |Lake
|roe     |Valentina|Roerich
|danforth|Frank    |Danforth

**Site**: Locations of the `sites` where readings were taken.

|name |lat   |long   |
|-----|------|-------|
|DR-1 |-49.85|-128.57|
|DR-3 |-47.15|-126.72|
|MSK-4|-48.87|-123.4 |

**Visited**: Specific identification `id` of the precise locations where readings were taken at the sites and dates.

|id   |site |dated     |
|-----|-----|----------|
|619  |DR-1 |1927-02-08|
|622  |DR-1 |1927-02-10|
|734  |DR-3 |1930-01-07|
|735  |DR-3 |1930-01-12|
|751  |DR-3 |1930-02-26|
|752  |DR-3 |-null-    |
|837  |MSK-4|1932-01-14|
|844  |DR-1 |1932-03-22|

  </div>
  <div class="col-md-6" markdown="1">

**Survey**: The measurements taken at each precise location on these sites. They are identified as `taken`. The field `quant` is short for quantity and indicates what is being measured.  The values are `rad`, `sal`, and `temp` referring to 'radiation', 'salinity' and 'temperature', respectively.

|taken|person|quant|reading|
|-----|------|-----|-------|
|619  |dyer  |rad  |9.82   |
|619  |dyer  |sal  |0.13   |
|622  |dyer  |rad  |7.8    |
|622  |dyer  |sal  |0.09   |
|734  |pb    |rad  |8.41   |
|734  |lake  |sal  |0.05   |
|734  |pb    |temp |-21.5  |
|735  |pb    |rad  |7.22   |
|735  |-null-|sal  |0.06   |
|735  |-null-|temp |-26.0  |
|751  |pb    |rad  |4.35   |
|751  |pb    |temp |-18.5  |
|751  |lake  |sal  |0.1    |
|752  |lake  |rad  |2.19   |
|752  |lake  |sal  |0.09   |
|752  |lake  |temp |-16.0  |
|752  |roe   |sal  |41.6   |
|837  |lake  |rad  |1.46   |
|837  |lake  |sal  |0.21   |
|837  |roe   |sal  |22.5   |
|844  |roe   |rad  |11.25  |

  </div>
</div>

## SQL `.tables` and `.schema`

In an interactive `sqlite3` session, 

- Type `.tables` to list the tables in the database
- Type `.schema` to see the SQL statements used to create the tables in the database.  The statements will have a list of the columns and the data types each column stores.

:::{.callout-tip}

### More about `.schema`

The output from `.schema` is formatted as <**columnName** *dataType*>.  

```{.sql filename="Output"}
CREATE TABLE Person (id text, personal text, family text);
CREATE TABLE Site (name text, lat real, long real);
CREATE TABLE Survey (taken integer, person text, quant text, reading real);
CREATE TABLE Visited (id integer, site text, dated text);
```

Thus we can see from the first line that the table **Person** has three columns:

- **id** with type _text_
- **personal** with type _text_
- **family** with type _text_

:::

The available data types vary based on the database manager - you can search online for what data types are supported.


# SQL command `SELECT`

For now, let's write an SQL query that displays scientists' names.

We do this using the SQL command `SELECT`, giving it the names of the 
columns we want and the table we want them from. 

Our query looks like this:

```{.sql filename="SQL"}
SELECT family, personal FROM Person;
```

And the output looks like this: 

```{.sql filename="Output"}
|family  |personal |
|--------|---------|
|Dyer    |William  |
|Pabodie |Frank    |
|Lake    |Anderson |
|Roerich |Valentina|
|Danforth|Frank    |
```

:::{.callout-tip}

### Important 

The **semicolon at the end of the query** tells the database manager that the query is complete and ready to run.

:::


We have written our commands in upper case and the names for the table and columns
in lower case, but we don't have to because SQL is **case insensitive**. 

```{.sql filename="SQL"}
SeLeCt FaMiLy, PeRsOnAl FrOm PeRsOn;
```

Output: 

```{.sql filename="Output"}
|family  |personal |
|--------|---------|
|Dyer    |William  |
|Pabodie |Frank    |
|Lake    |Anderson |
|Roerich |Valentina|
|Danforth|Frank    |
```

:::{.callout-tip}

### Pro-tip

You can use SQL's case insensitivity to distinguish between different parts of an SQL statement.

Here, we use the convention of using 

- UPPER CASE for SQL keywords (such as `SELECT` and `FROM`)
- Title Case for table names
- lower case for field names

Whatever casing convention you choose, please be consistent: complex queries are hard
enough to read without the extra cognitive load of random
capitalization.

:::



:::{.callout-tip}

### More about the `;`

While we are on the topic of SQL's syntax, one aspect of SQL's syntax
that can frustrate novices and experts alike is forgetting to finish a
command with `;` (semicolon).  

When you press enter for a command
without adding the `;` to the end, it can look something like this:

```{.sql filename="Output"}
SELECT id FROM Person
...>
...>
```

This is SQL's prompt, where it is waiting for additional commands or
for a `;` to let SQL know to finish.  

This is easy to fix!  Just type `;` and press enter!

:::

## More about `SELECT`

Row and columns in a database table are not actually stored in any particular order.

They will **always be displayed** in some order, but we can control that in various ways.

:::{.callout-note}

### Example

We could swap the columns in the output by writing our query as:

```{.sql filename="SQL"}
SELECT personal, family FROM Person;
```

```{.sql filename="Output"}
|personal |family  |
|---------|--------|
|William  |Dyer    |
|Frank    |Pabodie |
|Anderson |Lake    |
|Valentina|Roerich |
|Frank    |Danforth|
```

or even repeat columns:

```{.sql filename="SQL"}
SELECT id, id, id FROM Person;
```

```{.sql filename="Output"}
|id      |id      |id      |
|--------|--------|--------|
|dyer    |dyer    |dyer    |
|pb      |pb      |pb      |
|lake    |lake    |lake    |
|roe     |roe     |roe     |
|danforth|danforth|danforth|
```

:::

### The `*` operator

As a shortcut, we can select all of the columns in a table using `*`:

```{.sql filename="SQL"}
SELECT * FROM Person;
```

```{.sql filename="Output"}
|id      |personal |family  |
|--------|---------|--------|
|dyer    |William  |Dyer    |
|pb      |Frank    |Pabodie |
|lake    |Anderson |Lake    |
|roe     |Valentina|Roerich |
|danforth|Frank    |Danforth|
```


## Sorting and removing duplicates

## Filtering 

## Calculating new values

## Missing data 

## Aggregation

## Combining Data

## Data Hygiene

## Creating and Modifying Data	


# SQL in R

## Reading SQL data

There are several ways to 
[query databases in R](https://db.rstudio.com/getting-started/database-queries/). 

First, we will download a `.sqlite` database. This is a portable version of a `SQL` database. 

For our purposes, we will use the 

- [chinook sqlite database](https://github.com/lerocha/chinook-database/blob/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite)

The database represents a "digital media store, including tables for artists, 
albums, media tracks, invoices and customers".

From the [Readme.md](https://github.com/lerocha/chinook-database) file: 

> Sample Data
> 
> Media related data was created using real data from an iTunes Library. ... Customer and employee information was manually created using fictitious names, addresses that can be located on Google maps, and other well formatted data (phone, fax, email, etc.). Sales information is auto generated using random data for a four year period.

Here we download the data to our `/data` folder: 

```{r}
library(here)
if(!file.exists(here("data", "Chinook.sqlite"))){
  file_url <- paste0("https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite")
  download.file(file_url,
                destfile=here("data", "Chinook.sqlite"))
}
```

We can list the files and see the `.sqlite` database: 

```{r}
list.files(here("data"))
```

## Connect to the SQL database

The main workhorse packages that we will use are the `DBI` and `dplyr` packages. 

Let's look at the `DBI::dbConnect()` help file

```{r}
#| eval: false
?DBI::dbConnect
```

So we need a driver and one example is `RSQLite::SQLite()`. 
Let's look at the help file

```{r}
#| eval: false
?RSQLite::SQLite
```

Ok, so with `RSQLite::SQLite()` and `DBI::dbConnect()` 
we can connect to a `SQLite` database. 

Let's try that 
with our `Chinook.sqlite` file that we downloaded.

```{r}
library(DBI)
conn <- DBI::dbConnect(drv = RSQLite::SQLite(), 
                       dbname = here("data", "Chinook.sqlite"))
conn
```

So we have opened up a connection with the SQLite database. 
Next, we can see what tables are available in the database 
using the `dbListTables()` function: 

```{r}
dbListTables(conn)
```

From RStudio's website, there are several ways to interact with 
SQL Databases. One of the simplest ways that we will use here is 
to leverage the `dplyr` framework. 

> "The `dplyr` package now has a generalized SQL backend for talking to databases, and the new `dbplyr` package translates R code into database-specific variants. As of this writing, SQL variants are supported for the following databases: Oracle, Microsoft SQL Server, PostgreSQL, Amazon Redshift, Apache Hive, and Apache Impala. More will follow over time.

So if we want to query a SQL databse with `dplyr`, the benefit of using `dbplyr` is: 

> "You can write your code in `dplyr` syntax, and `dplyr` will translate your code into SQL. There are several benefits to writing queries in `dplyr` syntax: you can keep the same consistent language both for R objects and database tables, no knowledge of SQL or the specific SQL variant is required, and you can take advantage of the fact that `dplyr` uses lazy evaluation.

Let's take a closer look at the `conn` database that we just connected to:

```{r}
library(dbplyr)
src_dbi(conn)
```

You can think of the multiple tables similar to having 
multiple worksheets in a spreadsheet. 

Let's try interacting with one. 

## Querying with `dplyr` syntax

First, let's look at the first ten rows in the 
`Album` table using the `tbl()` function from `dplyr`: 

```{r}
tbl(conn, "Album") %>%
  head(n=10)
```

The output looks just like a `data.frame` that we are familiar 
with. But it's important to know that it's not really 
a dataframe. For example, what about if we use 
the `dim()` function? 

```{r}
tbl(conn, "Album") %>%
  dim()
```

Interesting! We see that the number of rows returned is `NA`. 
This is because these functions are different than operating 
on datasets in memory (e.g. loading data into memory using 
`read_csv()`). Instead, `dplyr` communicates differently 
with a SQLite database. 

Let's consider our example. If we were to use straight SQL, 
the following SQL query returns the first 10 rows 
from the `Album` table:

``` sql
SELECT *
FROM `Album`
LIMIT 10
```

In the background, `dplyr` does the following: 

* translates your R code into SQL
* submits it to the database
* translates the database's response into an R data frame

To better understand the `dplyr` code, we can use the 
`show_query()` function: 

```{r}
Album <- tbl(conn, "Album")
show_query(head(Album, n = 10))
```

This is nice because instead of having to write the 
SQL query our self, we can just use the `dplyr` and R 
syntax that we are used to. 

However, the downside is that `dplyr` never gets to see the 
full `Album` table. It only sends our query to the database, 
waits for a response and returns the query. However, in this 
way we can interact with large datasets! 

Many of the usual `dplyr` functions are available too: 

* `select()`
* `filter()`
* `summarize()` 

and many join functions. 

Ok let's try some of the functions out. 
First, let's count how many albums each 
artist has made. 

```{r}
tbl(conn, "Album") %>%
  group_by(ArtistId) %>% 
  summarize(n = count(ArtistId)) %>% 
  head(n=10)
```

# data viz 

Next, let's plot it. 

```{r}
tbl(conn, "Album") %>%
  group_by(ArtistId) %>% 
  summarize(n = count(ArtistId)) %>% 
  arrange(desc(n)) %>% 
  ggplot(aes(x = ArtistId, y = n)) + 
  geom_bar(stat = "identity")
```

Let's also extract the first letter from each 
album and plot the frequency of each letter. 

```{r}
tbl(conn, "Album") %>%
  mutate(first_letter = str_sub(Title, end = 1)) %>% 
  ggplot(aes(first_letter)) + 
  geom_bar()
```



# Post-lecture materials

### Final Questions

Here are some post-lecture questions to help you think about the material discussed.

::: callout-note
### Questions

Using the `survey.db` database: 

1. Use `.schema` to identify column that contains integers
2. Write a query that selects only the `name` column from the `Site` table.
3. Many people format queries in the following two ways. What style do you find easiest to read, and why?

```
SELECT personal, family FROM person;
```

or

```
select Personal, Family from PERSON;
```

4. 



:::

### Additional Resources

::: callout-tip

- <https://dbi.r-dbi.org>
- <https://solutions.posit.co/connections/db/databases/sqlite/>
- <https://dbplyr.tidyverse.org>

:::

